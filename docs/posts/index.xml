<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on &lt;Qutrits/&gt;</title>
    <link>https://qutrits.github.io/posts/</link>
    <description>Recent content in Posts on &lt;Qutrits/&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 06 Dec 2021 15:58:16 +0900</lastBuildDate><atom:link href="https://qutrits.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Markdown Syntax Guide For L2</title>
      <link>https://qutrits.github.io/posts/themes-guide/markdown-syntax.fr/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/themes-guide/markdown-syntax.fr/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide For RTL</title>
      <link>https://qutrits.github.io/posts/themes-guide/markdown-syntax.fa/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/themes-guide/markdown-syntax.fa/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>타이머를 이용해 스킬아이콘을 만들어보자!</title>
      <link>https://qutrits.github.io/posts/2021_12_06_03/</link>
      <pubDate>Mon, 06 Dec 2021 15:58:16 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_12_06_03/</guid>
      <description>🍑 타이머
public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action&amp;lt;float&amp;gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작 if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지 IEnumerator CoStartTimer(int time, Action&amp;lt;float&amp;gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break! if (timer &amp;gt;= time) { break; } //시간을 더해주자! timer += Time.</description>
    </item>
    
    <item>
      <title>Tween 만들기 프로젝트 근황</title>
      <link>https://qutrits.github.io/posts/2021_12_06_02/</link>
      <pubDate>Mon, 06 Dec 2021 15:34:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_12_06_02/</guid>
      <description>애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.
🍑 핑퐁 기능 추가!!!!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!</description>
    </item>
    
    <item>
      <title>inheritance: 상속</title>
      <link>https://qutrits.github.io/posts/2021_12_06_01/</link>
      <pubDate>Mon, 06 Dec 2021 00:25:53 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_12_06_01/</guid>
      <description>상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.
💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다.</description>
    </item>
    
    <item>
      <title>abstract class: 추상클래스</title>
      <link>https://qutrits.github.io/posts/2021_12_05_01/</link>
      <pubDate>Thu, 02 Dec 2021 23:13:57 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_12_05_01/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 11068</title>
      <link>https://qutrits.github.io/posts/2021_11_26_01/</link>
      <pubDate>Fri, 26 Nov 2021 00:18:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_26_01/</guid>
      <description>알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.</description>
    </item>
    
    <item>
      <title>Draw Call: 드로우콜(2)</title>
      <link>https://qutrits.github.io/posts/2021_11_25_03/</link>
      <pubDate>Thu, 25 Nov 2021 00:05:33 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_25_03/</guid>
      <description>이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.
Batch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명
Project Setting &amp;gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적.</description>
    </item>
    
    <item>
      <title>Draw Call: 드로우콜(1)</title>
      <link>https://qutrits.github.io/posts/2021_11_25_02/</link>
      <pubDate>Wed, 24 Nov 2021 23:19:40 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_25_02/</guid>
      <description>오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!
Draw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명
 오브젝트가 실제 화면에 렌더링 되려면 CPU -&amp;gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재.</description>
    </item>
    
    <item>
      <title>Generic: 제너릭 클래스</title>
      <link>https://qutrits.github.io/posts/2021_11_25_01/</link>
      <pubDate>Tue, 23 Nov 2021 23:32:06 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_25_01/</guid>
      <description>유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.
Generic class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.</description>
    </item>
    
    <item>
      <title>C#_string_StringBuilder</title>
      <link>https://qutrits.github.io/posts/2021_11_19_01/</link>
      <pubDate>Fri, 19 Nov 2021 08:54:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_19_01/</guid>
      <description>C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = &amp;#34;안녕&amp;#34; + &amp;#34;하세요&amp;#34;; //&amp;#34;안녕&amp;#34; &amp;#34;하세요&amp;#34; -&amp;gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -&amp;gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다.</description>
    </item>
    
    <item>
      <title>Extenstion Method: 확장 메서드</title>
      <link>https://qutrits.github.io/posts/2021_11_18_02/</link>
      <pubDate>Thu, 18 Nov 2021 15:49:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_18_02/</guid>
      <description>유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.
  나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method 를 이용하면 되는 것!
 Extenstion Method가 뭐야? 🧐  특수한 종류의 Static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 13116</title>
      <link>https://qutrits.github.io/posts/2021_11_24_01/</link>
      <pubDate>Wed, 17 Nov 2021 23:11:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_24_01/</guid>
      <description>알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.
하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.
이미지 보러가기
문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 9461</title>
      <link>https://qutrits.github.io/posts/2021_11_24_02/</link>
      <pubDate>Mon, 15 Nov 2021 00:26:56 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_24_02/</guid>
      <description>알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.
파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.
N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://qutrits.github.io/posts/2021_11_18_01/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_18_01/</guid>
      <description>Desc Text.</description>
    </item>
    
    <item>
      <title>[아이템 33] 타입 안전 이종 컨테이너를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item33/</link>
      <pubDate>Thu, 09 Jul 2020 18:21:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item33/</guid>
      <description>[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.
1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public &amp;lt;T&amp;gt; void putFavorite(Class&amp;lt;T&amp;gt; type, T instance); public &amp;lt;T&amp;gt; getFavorite(Class&amp;lt;T&amp;gt; type) }   다음은 Favorite 클래스를 사용하는 예시입니다.
1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트  Favorites f = new Favorites(); f.</description>
    </item>
    
    <item>
      <title>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item32/</link>
      <pubDate>Thu, 09 Jul 2020 16:12:48 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item32/</guid>
      <description>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.
가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.
실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item31/</link>
      <pubDate>Thu, 09 Jul 2020 13:42:19 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item31/</guid>
      <description>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.
아이템29의 Stack 클래스를 떠올려보면
1 2 3 4 5 6  public class Stack&amp;lt;T&amp;gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면
1 2 3 4 5  public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다.</description>
    </item>
    
    <item>
      <title>[아이템 30] 이왕이면 제네릭 메서드로 만들라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item30/</link>
      <pubDate>Thu, 09 Jul 2020 10:24:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item30/</guid>
      <description>[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.
1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 29] 이왕이면 제네릭 타입으로 만들라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item29/</link>
      <pubDate>Wed, 08 Jul 2020 16:53:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item29/</guid>
      <description>[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack&amp;lt;E&amp;gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } .</description>
    </item>
    
    <item>
      <title>[아이템 28] 배열보다는 리스트를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item28/</link>
      <pubDate>Wed, 08 Jul 2020 14:21:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item28/</guid>
      <description>[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.
반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입도 아니고 상위 타입도 아닙니다.
이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.
1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = &amp;#34;타입이 달라 넣을 수 없다.</description>
    </item>
    
    <item>
      <title>[아이템 27] 비검사 경고를 제거하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item27/</link>
      <pubDate>Wed, 08 Jul 2020 13:16:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item27/</guid>
      <description>[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.
제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.
대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.
1  Set&amp;lt;Fruits&amp;gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.</description>
    </item>
    
    <item>
      <title>[아이템 26] Raw 타입은 사용하지 마라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item26/</link>
      <pubDate>Tue, 07 Jul 2020 11:41:27 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item26/</guid>
      <description>[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.
1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.
1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 25] 톱레벨 클래스는 한 파일에만 담으라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item25/</link>
      <pubDate>Sun, 05 Jul 2020 13:12:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item25/</guid>
      <description>[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.
Utensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.
1 2 3 4 5 6 7  class Utensil { static final String NAME = &amp;#34;pan&amp;#34;; } class Dessert { static final String NAME = &amp;#34;cake&amp;#34;; }   Main을 실행하면 &amp;ldquo;pancake&amp;quot;가 출력됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 24] 멤버 클래스는 되도록 static으로 만들어라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item24/</link>
      <pubDate>Sun, 05 Jul 2020 11:41:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item24/</guid>
      <description>[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.
중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.
 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.
정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다.</description>
    </item>
    
    <item>
      <title>[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item23/</link>
      <pubDate>Sat, 04 Jul 2020 15:46:26 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item23/</guid>
      <description>[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.
안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.</description>
    </item>
    
    <item>
      <title>[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item22/</link>
      <pubDate>Sat, 04 Jul 2020 13:21:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item22/</guid>
      <description>[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.
이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.
1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.</description>
    </item>
    
    <item>
      <title>[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item21/</link>
      <pubDate>Sat, 04 Jul 2020 11:14:32 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item21/</guid>
      <description>[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.
JAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.
즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.
자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.</description>
    </item>
    
    <item>
      <title>[아이템 20] 추상 클래스보다는 인터페이스를 우선하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item20/</link>
      <pubDate>Fri, 03 Jul 2020 14:21:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item20/</guid>
      <description>[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.
추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.
반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item19/</link>
      <pubDate>Fri, 03 Jul 2020 13:57:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item19/</guid>
      <description>[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.
상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 18] 상속보다는 컴포지션을 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item18/</link>
      <pubDate>Fri, 03 Jul 2020 11:42:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item18/</guid>
      <description>[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.
상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.
예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.</description>
    </item>
    
    <item>
      <title>[아이템 17] 변경 가능성을 최소화하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item17/</link>
      <pubDate>Thu, 02 Jul 2020 14:11:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item17/</guid>
      <description>[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점
클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item16/</link>
      <pubDate>Thu, 02 Jul 2020 13:38:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item16/</guid>
      <description>[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item15/</link>
      <pubDate>Thu, 02 Jul 2020 12:52:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item15/</guid>
      <description>[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.
정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다.</description>
    </item>
    
    <item>
      <title>[아이템 14] Comparable를 구현할지 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item14/</link>
      <pubDate>Sat, 27 Jun 2020 17:11:39 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item14/</guid>
      <description>[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다. Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.
1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다.</description>
    </item>
    
    <item>
      <title>[아이템 13] clone 재정의는 주의해서 진행하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item13/</link>
      <pubDate>Sat, 27 Jun 2020 15:04:12 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item13/</guid>
      <description>[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다. 하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다. 이 객체의 복사본을 생성해 반환합니다. &amp;lsquo;복사&amp;rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.
 x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다.</description>
    </item>
    
    <item>
      <title>[아이템 12] toString을 항상 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item12/</link>
      <pubDate>Sat, 27 Jun 2020 14:31:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item12/</guid>
      <description>[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다. 이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.
1 2  Student student = new Student(&amp;#34;kim&amp;#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.
toString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item11/</link>
      <pubDate>Sat, 27 Jun 2020 13:18:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item11/</guid>
      <description>[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.  equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해쉬테이블의 성능이 좋아집니다.</description>
    </item>
    
    <item>
      <title>[아이템 10] equals는 일반 규약을 지켜 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item10/</link>
      <pubDate>Sat, 27 Jun 2020 11:42:54 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item10/</guid>
      <description>[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.equals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다. 반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반</description>
    </item>
    
    <item>
      <title>[아이템 9] try-finally보다는 try-with-resources를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item9/</link>
      <pubDate>Sat, 20 Jun 2020 17:12:16 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item9/</guid>
      <description>[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 닫아(close)해줘야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.
1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다.</description>
    </item>
    
    <item>
      <title>[아이템 8] `finalizer`와 `cleaner` 사용을 피하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item8/</link>
      <pubDate>Sat, 20 Jun 2020 15:12:33 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item8/</guid>
      <description>[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.
cleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.
단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.
finalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다.</description>
    </item>
    
    <item>
      <title>[아이템 7] 다 쓴 객체 참조를 해제하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item7/</link>
      <pubDate>Sat, 20 Jun 2020 12:15:43 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item7/</guid>
      <description>[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.</description>
    </item>
    
    <item>
      <title>[아이템 6] 불피요한 객체를 생성을 피하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item6/</link>
      <pubDate>Fri, 19 Jun 2020 18:33:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item6/</guid>
      <description>[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.
문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(&amp;#34;hello&amp;#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.
리터럴 방식 1  String str = &amp;#34;hello&amp;#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.</description>
    </item>
    
    <item>
      <title>[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item5/</link>
      <pubDate>Fri, 19 Jun 2020 17:15:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item5/</guid>
      <description>[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.
부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List&amp;lt;String&amp;gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = .</description>
    </item>
    
    <item>
      <title>[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item4/</link>
      <pubDate>Fri, 19 Jun 2020 15:51:43 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item4/</guid>
      <description>[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.
매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.
1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 3] private 생성자나 열거 타입으로  싱글턴임을 보증하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item3/</link>
      <pubDate>Thu, 18 Jun 2020 19:09:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item3/</guid>
      <description>[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.
싱글턴을 만드는 방식은 보통 둘 중 하나입니다.
public static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { .</description>
    </item>
    
    <item>
      <title>[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item2/</link>
      <pubDate>Thu, 18 Jun 2020 17:21:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item2/</guid>
      <description>[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.
첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 1] 생성자 대신 정적 팩토리 메서드를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item1/</link>
      <pubDate>Thu, 18 Jun 2020 15:49:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item1/</guid>
      <description>[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드
1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.
반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide</title>
      <link>https://qutrits.github.io/posts/2021_11_19_02/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/2021_11_19_02/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide</title>
      <link>https://qutrits.github.io/posts/themes-guide/markdown-syntax/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/themes-guide/markdown-syntax/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>Rich Content</title>
      <link>https://qutrits.github.io/posts/rich-content/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/rich-content/</guid>
      <description>A brief description of Hugo Shortcodes</description>
    </item>
    
    <item>
      <title>Placeholder Text</title>
      <link>https://qutrits.github.io/posts/placeholder-text/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/placeholder-text/</guid>
      <description>Lorem Ipsum Dolor Si Amet</description>
    </item>
    
    <item>
      <title>Math Typesetting</title>
      <link>https://qutrits.github.io/posts/math-typesetting/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/math-typesetting/</guid>
      <description>A brief guide to setup KaTeX</description>
    </item>
    
    <item>
      <title>Emoji Support</title>
      <link>https://qutrits.github.io/posts/emoji-support/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/emoji-support/</guid>
      <description>Guide to emoji usage in Hugo</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item34/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item34/</guid>
      <description>[아이템 34] int 상수 대신 열거 타입을 사용하라. 열거 타입이란 일정 개수의 상수 값을 정의하고 그 이외 값들은 허용하지 않는 타입입니다. 대표적으로 사계절, 요일, 태양계의 행성 등이 있습니다.
열거 타입을 지원하기 전 코드 1 2 3 4 5  // 정수 열거 패턴 - 상당히 취약하다. public static final int EAST = 0; public static final int WEST = 1; public static final int SOUTH = 2; public static final int NORTH = 3;   이 코드는 타입의 안전성을 보장할 수 없고 표현력도 좋지 않습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item35/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item35/</guid>
      <description>[아이템 35] ordinal 메서드 대신 인스턴스 필드를 사용하라 대부분 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응됩니다. 모든 엵 ㅓ타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal 이라는 메서드를 제공합니다.
1 2 3 4 5 6 7 8 9 10  // ordinal을 잘못 사용한 예 public enum FRUITS { APPLE, BANANA, ORANGE; public int numberOfFruits() { return ordinal() + 1; } }   상수 선언 순서를 바꾸는 순간 numberOfFruits는 오작동하며 이미 사용중인 정수와 값이 같은 상수는 추가할 수 없고 중간에 값을 비울 수도 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item36/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item36/</guid>
      <description>[아이템 36] 비트 필드 대신 EnumSet을 사용하라. 열거한 값들이 집합으로 사용될 경우, 예전에는 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔습니다.
1 2 3 4 5 6 7 8 9 10  // 비트 필드 열거 상수 - 구닥다리 기법  public class Text { public static final int STYLE_BOLD = 1 &amp;lt;&amp;lt; 0; // 1  public static final int STYLE_ITALIC = 1 &amp;lt;&amp;lt; 1; // 2  public static final int STYLE_UNDERLINE = 1 &amp;lt;&amp;lt; 2; // 4  public static final int STYLE_STRIKETHROUGH = 1 &amp;lt;&amp;lt; 3; // 8  // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item37/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item37/</guid>
      <description>[아이템 37] ordinal 인덱싱 대신 EnumMap을 사용하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Plant { enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL } final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle; } @Override public String toString() { return name; } }   식물을 간단히 나타낸 코드입니다. 이들을 생애주기 별로 묶어봅시다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item38/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item38/</guid>
      <description>[아이템 38] 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라. 열거 타입은 확장할 수 없게 설계 되었습니다. 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 어폐가 있고 기반 타입과 확장된 타입들의 원소를 모두를 순회할 방법도 마땅치 않으며 확장성을 높이려면 고려할 요소가 늘어나 설계와 구현이 더 복잡해지기 때문입니다. 그러나 연산 코드는 확장할 수 있는 열거 타입과 어울립니다. API가 제공하는 기본 연산 외에 사용자가 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item39/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item39/</guid>
      <description>[아이템 39] 명명 패턴보다 애너테이션을 사용하라. 명명 패턴의 대표적인 예로 JUnit 3까지는 테스트 메서드 이름을 test로 시작하지 않으면 이 메서드를 그냥 지나쳤서 테스트를 통과했다고 오해하는 경우도 있었습니다.JUnit 4부터는 이러한 문제점을 해결하기 위해 애너테이션을 전면 도입했습니다. 이번 예제에서는 자동으로 수행되는 간단한 테스트용 애너테이션으로, 예외가 발생하면 해당 테스트를 실패로 처리합니다.
1 2 3 4 5 6 7 8  /** * 테스트 메서드임을 선언하는 애너테이션 * 매개변수 없는 정적 메서드 전용 */ @Retention(RetentionPolicy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item40/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item40/</guid>
      <description>[아이템 40] @Override 애너테이션을 일관되게 사용하여라. @Override애너테이션은 상위 타입 메서드를 재정의 했다는 뜻으로 메서드 선언에 달 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 버그를 찾아보자  public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item41/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-05/item41/</guid>
      <description>[아이템 41] 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라. 마커 인터페이스란 메서드 선언을 포함하지 않고, 단지 구현하는 클래스의 특정 속성을 표시해주는 것입니다. 대표적으로 Serializable인터페이스가 있습니다.마커 애너테이션이 등장하면서 마커 인터페이스가 구식이 되었다는 얘기가 있는데, 이는 사실이 아닙니다. 마커 인터페이스는 마커 애너테이션 보다 좋은 점도 있습니다.첫 째로 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입을 쓸 수 있지만, 마커 애너테이션은 그렇지 않습니다. 마커 인터페이스는 타입이고 마커 애너테이션을 사용하면 런타임에야 발견할 수 있습니다.자바의 직렬화는 Serializable 마커 인터페이스를 보고 그 대상이 직렬화를 할 수 있는 타입인지 확인합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item42/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item42/</guid>
      <description>[아이템 42] 익명 클래스보다는 람다를 사용하라. 자바 8부터는 함수형 프로그래밍을 지원합니다. 추상 메서드가 하나인(Single Abstract Method)인터페이스를 함수형 인터페이스라고 부르며 람다식을 사용해 만들 수 있습니다. 람다는 익명클래스에 비해 코드가 간결하고 가독성이 좋다는 장점이 있습니다.
1 2 3 4 5 6 7  // 익명 클래스 방식 Collections.sort(words, new Comparator&amp;lt;String&amp;gt;() { @Override public int compare(String s1, String s2) { return Interget.compare(s1.length(), s2.length()); } });   1 2 3  // 람다 활용 Collections.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item43/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item43/</guid>
      <description>[아이템 43] 람다보다는 메서드 참조를 사용하라. 메서드 참조를 이용하면 람다보다 간단하게 코드를 작성할 수 있습니다.
 문법 클래스이름::메소드이름또는참조변수이름::메소드이름
 다음의 예제 코드는 키가 맵에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값에 1을 증가시킵니다.
1  map.merger(key, 1, (count, incr) -&amp;gt; count + incr);   위 코드는 Integer의 sum메서드를 이용해서 대체할 수 있으며 메서드 참조를 이용해 간결하게 표현할 수 있습니다.
1  map.merger(key, 1, Integer::sum);   메서드 참조를 이용하면 코드가 간결해지며 가독성이 좋아지는 경우가 있지만 때로는 람다에서는 매개변수의 이름으로 가이드를 할 수도 있고 메서드 참조보다 더 읽기 쉽고 가독성이 더 좋아지는 경우가 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item44/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item44/</guid>
      <description>[아이템 44] 표준 함수형 인터페이스를 사용하라. java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 정의되어 있으므로 용도에 맞는 게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용합시다. 일관성을 높일 수 있고 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 증가할 것입니다. java.util.function에는 총 43개의 인터페이스가 있지만 기본 인터페이스 6개만 기억하면 나머지는 충분히 유추할 수 있으며 나머지는 필요할 때마다 찾아서 사용하면 됩니다. 표준 함수형 인터페이스 대부분은 기본 타입만 지원합니다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하지 맙시다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item45/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item45/</guid>
      <description>[아이템 45] 스트림은 주의해서 사용하라. 스트림이 제공하는 핵심 개념 중 핵심은 두 가지로 나눌 수 있습니다.
 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻합니다. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념입니다.  스트림은 소스 스트림으로 시작해서 종단(최종) 연산(terminal operation)으로 끝나며, 그 사이에 하나 이상의 중간 연산자가 있을 수 있습니다. 중간 연산자는 어떠한 방식으로 변환(transform) 합니다. 최종 연산은 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item46/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item46/</guid>
      <description>[아이템 46] 스트림에서는 부작용이 없는 함수를 사용하라. 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분입니다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 하는데, 순수 함수란 입력만이 결과에 영향을 주는 함수를 말합니다. 즉 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않습니다.다음은 텍스트 파일에서 단어별 수를 세어 빈도표를 만드는 코드입니다.
1 2 3 4 5 6 7  // 스트림을 이해하지 못한 코드 - 따라 하지 말 것 Map&amp;lt;String, Long&amp;gt; freq = new HashMap&amp;lt;&amp;gt;(); try (Stream&amp;lt;String&amp;gt; words = new Scanner(file).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item47/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item47/</guid>
      <description>[아이템 47] 반환 타입으로는 스트림보다 컬렉션이 낫다. 사실 Stream 인터페이스 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 Iterable 인터페이스가 정의한 방식대로 동작합니다. 하지만 for-each로 스트림을 반복할 수 없는 이유는 Stream이 Iterable을 확장하지 않아서입니다. Collection인터페이스는 Iterable의 하위 타입이고 stream의 메서드도 제공하니 반복과 스트림을 동시에 지원합니다. 따라서 원소 시퀀수를 공개하는 공개 API의 반환타입에는 Collection이나 그 하위 타입을 사용하는게 일반적으로 좋습니다.
정리  원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하길 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 고려하라 컬렉션을 반환할 수 있다면 그렇게 하고 반환 전부터 이미 원소들을 컬렉션에 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList같은 표준 컬렉션에 담아 반환하라.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item48/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-06/item48/</guid>
      <description>[아이템 48] 스트림 병렬화는 주의해서 적용하라. 자바 8에 추가된 parallel 메서드는 파이프라인을 병렬 실행할 수 있습니다. 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 주의를 기울여야합니다. 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없습니다. 대체로 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋습니다. 이 자료구조들은 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특성이 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item49/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item49/</guid>
      <description>매개변수가 유효한지 검사하라. 메서드와 생성자는 대부분 특정 조건의 입력 매개변수에 특정 조건을 만족하기를 바랍니다. 만일 잘못된 값이 들어올 경우 보통 예외를 던지거나 컴파일 오류를 잡아내긴 하지만, 오류는 가능한 빨리 잡아내는 게 좋습니다. 그렇지 않으면 감지하기 어려워지고 감지하더라도 찾아내기 힘들어지는 경우도 있습니다.이러한 경우를 방지하기 위해 매개변수를 미리 확인한다면 즉각적이고 깔끔한 방식으로 예외를 처리할 수 있습니다. 하지만 반드시 메서드를 실행하기 전에 매개변수 유효성 검사를 해야하는 것만은 아닙니다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때는 다시 고려를 해봐야 합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item50/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item50/</guid>
      <description>[Item50] 적시에 방어적 복사본을 만들라 이번 아이템에서는 지난 Item17에 다루었던 불변에 대한 주제가 포함되어있습니다. 어떤 객체든 객체의 허락 없이는 외부에서 함부로 내부를 수정하게 하는 일이 없아야 합니다. 하지만 주의를 기울이지 않으면 자신도 모르게 내부를 수정하도록 코드를 짜는 경우가 생길 수 있습니다. 다음은 부주의로 일어날 수 있는 상황을 예시로 든 코드입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public final class Period { private final Date date; private final Date end; public Period(Date start, Date end) { if (start.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item51/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item51/</guid>
      <description>[아이템 51] 메서드 시그니처를 신중히 설계하라. 메서드 이름을 신중히 짓자. 항상 표준 명명 규칙을 따라야합니다. 이름만 보고 이해할 수 있고, 일관성있게 짓는 것이 핵심입니다. 그 다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것입니다. 되도록이면 긴 이름은 피하는 것이 좋습니다. 물론 조직내에 규율이 있다면 그 규율을 지키는 게 우선입니다.
편의 메서드를 너무 만들지 말자. 메서드가 너무 많은 클래스는 파악하고 유지보수 하기도 힘들고 객체지향 SOLID원칙 중 Single Responsiblity Principle에 위반될 수도 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item52/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item52/</guid>
      <description>[아이템 52] 다중정의는 신중히 사용하라. 다음은 컬렉션을 집합, 리스트, 그 외로 구분하고자 만든 프로그램입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class CollectionClassifier { public static String classify(Set&amp;lt;?&amp;gt; s) { return &amp;#34;Set&amp;#34;; } public static String classify(List&amp;lt;?&amp;gt; lst) { return &amp;#34;List&amp;#34;; } public static String classify(Collection&amp;lt;?&amp;gt; c) { return &amp;#34;Unknown Collection&amp;#34;; } public static void main(String[] args) { Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item53/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item53/</guid>
      <description>[아이템 53] 가변인수는 신중히 사용하라. 가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있습니다. 다음 예제는 int 인자의 합을 구하는 가변인수 메서드입니다.
1 2 3 4 5 6 7  static int sum(int... args) { int sum = 0; for (int args: args) { sum += args; } return sum; }   1개 이상의 인수가 필요한 경우도 있습니다. 다음 예제는 1개 이상의 인수를 필요료하는 가변인수 메서드의 잘못된 구현입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item54/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item54/</guid>
      <description>[아이템 54] null이 아닌, 빈 컬렉션이나 배열을 반환하라. 1 2 3 4 5 6  // 컬렉션이 비어있으면 null을 반환 - 따라하지 말 것 private final List&amp;lt;Cheese&amp;gt; cheesesInStock = ...; public List&amp;lt;Cheese&amp;gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList&amp;lt;&amp;gt;(cheesesInStock); }   null을 반환할 경우 클라이어트는 이 null 상황을 처리하는 코드를 추가로 작성해야합니다.
1 2 3 4  List&amp;lt;Cheese&amp;gt; cheesesInStock = shop.getCheeses(); if (cheese != null &amp;amp;&amp;amp; cheeses.contains(cheese.STILTON)) { system.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item55/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item55/</guid>
      <description>[아이템 55] 옵셔널 반환은 신중히 하라 자바 8이전에는 메서드가 특정 값을 반환할 수 없을때 취할 수 있는 선택지가 두 가지가 있었습니다. 예외를 던지거나, null을 반환하는 것입니다. 두 방법 모두 허점이 있습니다. 예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 바용도 만만치 않습니다. null을 반환할 수 있는 메서드를 호출하면 null 처리를 별도로 해줘야합니다. null 처리를 무시하면 나중에 NPE가 발생할 수 있습니다. 자바 8부터는 Optional을 지원했습니다. Optional&amp;lt;T&amp;gt;는 null이 아닌 T타입 참조를 하나 담거나, 아무것도 담지 않을 수 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item56/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-07/item56/</guid>
      <description>[아이템 56] 공개된 API 요소에는 항상 문서화 주석을 작성하라. javadocd이라는 유틸리티를 이용하면 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해줍니다.메서드용 문서화 주석에는 해당 메서드와 클라이어트 사이의 규약을 명료하게 기술해야 합니다. 핵심 포인트는 how가 아닌 what입니다. 무엇을 하는지에 대한 설명이 있어야 합니다. 또한 메서드를 호출하기위한 조건, 수행된 후에 만족해야 하는 사후조건, 부작용도 모두 나열되어야 합니다. 잘 쓰인 문서인지 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길뿐입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item57/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item57/</guid>
      <description>[아이템 57] 지역변수의 범위를 최소화하라. 지역변수의 범위는 가능한 좁히는 게 좋습니다. 가장 좋은 방법은 선언과 동사에 초기화 해주는 것입니다. 초기화에 필요한 정보가 없다면 정보가 주어질 때까지 선언을 미루는 것입니다.. 물론 try-catch문은 이 규칙에서 예외입니다. try 블록 안에서 초기화해야하고 밖에서도 쓰일 경우 try 블록 앞에서 선언해야 합니다. 이러한 지역변수 초기화는 대표적으로 for (for-each), while로 비교할 수 있습니다.
1 2 3 4  // 컬렉션이나 베열을 순회하는 권장 관용구 for (Element e : c) { .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item58/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item58/</guid>
      <description>[아이템 58] 전통적인 for 문보다는 for-each를 사용하라. for 문은 코드가 장황해질 수 있고, 요소 종류가 늘어날 수록 오류가 생길 가능성이 있습니다. for-each (정식명칭 향상된 for문)은 이러한 단점들을 해결해줄 수 있습니다.
1 2 3  for (Element e : elements) { .... // e로 무언가를 한다. }   컬렉션을 중첩해서 사용하면 for-each 문의 이점은 더욱 커집니다.
1 2 3 4 5 6 7 8 9 10 11 12 13  // 버그를 찾아보자 enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item59/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item59/</guid>
      <description>[아이템 59] 라이브러리를 익히고 사용하라. 0부터 명시한 수 까지 무작위 정수를 하나 생성하려고 합니다. 다음은 흔히 마주할 수 있는 문제있는 메서드입니다.
1 2 3 4 5  static Random ran = new Randon(); static int random(int n) { return Math.abs(ran.nextInt()) % n; }   이 코드에는 세 가지 문제점이 있습니다. 첫 번째. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복됩니다. 두 번째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 반복됩니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item60/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item60/</guid>
      <description>[아이템 60] 정확한 답이 필요하다면 float와 double은 피하라. float와 dobule은 과학과 공학 계산용으로 설계 되었습니다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &amp;lsquo;근사치&amp;rsquo;로 계산하도록 설계되었습니다. 따라서 정확한 계산 결과가 필요할 때는 사용하면 안 됩니다. 특 히 금용 관련 계산과 맞지 않습니다. 0.1 혹은 10의 음의 거듭 제곱수(10^-1, 10-^2)를 표현할 수 없기 때문입니다.예를 들어 1.03달러에서 42센트를 사용하고 남은 돈을 계산한다고 가정해봅시다.
1  System.out.println(1.03 - 0.42);   이 코드는 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item61/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item61/</guid>
      <description>[아이템 61] 박싱된 기본 타입보다는 기본 타입을 사용하라. 자바의 데이터 타입은 기본형과 참조형이 있습니다. 기본형에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 합니다. 기본 타입과 박싱된 기본 타입은 분명한 차이가 있으며 용도에 맞게 사용해야합니다.박싱된 기본 타입은 값 뿐만 아니라 식별성이 더해졌습니다. 즉 값이 같아도 서로 다르게 식별될 수 있습니다. 그리고 박싱 타입은 null을 가질 수 있습니다. 추가로 기본 타입은 박싱 타입보다 메모리와 시간 측면에서 더 효율적입니다.1 2 3  // 잘못 구현된 비교자 Comparator&amp;lt;Integer&amp;gt; naturalOrder = (i, j) -&amp;gt; (i &amp;lt; j) ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item62/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item62/</guid>
      <description>[아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라. 문자열은 다른 값 타입을 대신하기엔 적절하지 않습니다.
1 2  // 흔한 타입을 문자열로 처리한 부적절한 예 String compoundKey = className + &amp;#34;#&amp;#34; + i.next();   두 요소를 구분해주는 #이 두 요소 중 하나에서 쓰였다면 혼란을 초래할 수 있습니다. 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커집니다. 이럴 경우 전용 클래스를 새로 만드는 편이 낫습니다. 보통 private 정적 멤버 클래스로 선언합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item63/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item63/</guid>
      <description># [아이템 63] 문자열 연결은 느리니 주의하라. 문자열 연결 연산자로 문자열을 n개를 잇는 시간은 n^2에 비례합니다. 문자열은 immutable이라 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없습니다.
1 2 3 4 5 6 7  public String statement() { String result = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; numItems(); i++) { result += lineForItem(); // 문자열연결  } return result; }   StringBuilder를 활용하면 성능을 크게 개선할 수 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item64/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item64/</guid>
      <description>[아이템 64] 객체는 인터페이스를 사용해 참조하라. 1 2  // 좋은 예 Set&amp;lt;Student&amp;gt; student = new HashSet&amp;lt;&amp;gt;();   1 2  // 나쁜 예. 클래스 참조 HashSet&amp;lt;Student&amp;gt; student = new HashSet&amp;lt;&amp;gt;();   인터페이스를 활용하면 유연함을 얻을 수 있습니다. 구현체를 교체하고 싶으면 구현 클래스만 바꾸면 됩니다.
1 2  // HashSet -&amp;gt; LinkedHashSet 교체 Set&amp;lt;Student&amp;gt; student = new LinkedHashSet&amp;lt;&amp;gt;();   하지만 구현체를 바꿀 경우 주의할 점이 있습니다. 기존 구현체만의 특별한 기능을 제공하는 게 있다면, 바꿀 구현체에도 있는지 혹은 사이드 이펙트도 충분히 고려해야 합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item65/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item65/</guid>
      <description>[아이템 65] 리플렉션보다는 인터페이스를 사용하라. 리플렉션 기능을 활용하면 클래스에 접근 할 수 있습니다. Class객체가 주어지면 생성자, 메서드, 필드에 해당하는 Consturct, Method, Field 인스턴스를 가져올 수 있고 그 인스턴스들로는 그 클래스의 시그니처 등을 가져올 수 있습니다. Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해줍니다 물론 장점만있는 건 아닙니다. 단점은 다음과 같습니다.
 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 예외 검사도 마찬가지입니다. 리플렉션 기능으로 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려고하면 런타임 오류가 발생합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item66/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item66/</guid>
      <description>[아이템 66] 네이티브 메서드는 신중히 사용하라. 자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다. 네이티브 메서드란 C나 C++같읕 네이비티브 프로그래밍 언어로 작성한 메서드를 말합니다. 네이티브 메서드의 주요 쓰임은 세 가지가 있습니다.
 레지스트리 같은 플랫폼 특화 기능을 사용한다. 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  자바 9부터는 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었고 자바에서 네이티브 메서드를 사용할 필요가 점점 줄어드는 추세입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item67/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item67/</guid>
      <description>[아이템 67] 최적화는 신중히 하라. 최적화는 좋은 결과보다 해로운 결과로 이어지기 쉽고, 자칫하면 빠르지도 않고 제대로 동작하지 않는 소프트웨어를 탄생시키는 것과 같습니다. 그러므로 최적화 할때는 득과실을 잘 생각해봐야 합니다.
성능을 제한하는 설계를 피하라 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리 혹은 외부 시스템과의 소통 방식입니다. 대표적으로 API, 네트워크 프로토콜 등이 있습ㄴ디ㅏ. 이런 설계 요소들은 완성 후에는 변경하기 어려우며 동시에 시스템 성능을 심각하게 제한할 수 있습니다.
API 설계할 때 성능에 주는 영향을 고려하라.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item68/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-08/item68/</guid>
      <description>[아이템 68] 일반적으로 통용되는 명명 규칙을 따르라. 자바이 명명 규칙은 크게 철자와 문법, 두 범주로 나뉘고 명명 규칙을 지켜야 좋은 프로그래밍이 될 수 있습니다. 대표적으로 메서드와 필드 내임의 첫 글자는 소문자를 사용합니다. 하지만 상수 필드의 경우 예외입니다. 상수는 모두 대무자를 이용하며 단어 사이는 _로 구분 합니다. ex)MAX_VALUE.. 상수 필드는 값이 static final 필드를 말합니다. 타입 매개변수 같은 경우 한 문자로 표현되며, 임의의 타입에는 T를, 컬렉션 원소의 타입은 E, 맵의 키와 값에는 K, V를, 예외는 X, 메서드의 반환 타입에는 R을 사용합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item69/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item69/</guid>
      <description>[아이템 69] 예외는 진짜 예외 상황에서만 사용하라. 예외는 반드시 예외 상황에서만 사용해야한다. 일반적인 제어 흐름용으로 사용하면 안 됩니다.
1 2 3 4 5 6 7 8  try { int i = 0; while (true) { index[i++].doSomething(); } } catch (ArrayIndexOutOfBoundsException) { .. }   코드가 장황하고 직관적이지 않습니다. 성능도 일반적인 제어 흐름보다 느립니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item70/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item70/</guid>
      <description>[아이템 70] 복구할 수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 시용하라. 자바에서는 기본적으로 오류는 checked exception, runtime exception, error 이렇게 세 가지로 나눌 수 있습니다. 100% 확실한 건 아니지만 일반적으로 사용하는 상황은 다음과 같습니다. 호출 하는 쪽에서 복구하리라 여거지는 상황에서는 검사 예외를 사용합시다. 이것이 검사 예외랑 비검사 예외를 구분하는 가장 기본적인 규칙입니다. catch로 잡아서 처리하거나 thorws로 예외를 호출한쪽으로 전파하고 호출했을 때 발생할 수 있는 있다는 걸 API 사용자에게 알리는 것입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item71/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item71/</guid>
      <description>[아이템 71] 필요 없는 검사 예외 사용은 피하라. 검사 예외를 필요한 곳에만 사용하면 프로그램의 안전성을 높여주지만, 과하게 사용하면 오히려 쓰기 불편한 API가 됩니다. API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 잇는 조치를 취할 수 있는 경우 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item72/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item72/</guid>
      <description>[아이템 72] 표준 예외를 사용하라. 자바에서는 기본적으로 다양한 예외를 제공해줍니다. 예외를 만들기 전 먼저 기존 라이브러리를 확인해보는 것이 좋습니다. 기존에 있는 라이브러리를 사용하면 API가 다른 사람이 익히기 쉬워집니다. 또한 예외 클래스가 적어질 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸리기 때문입니다. Exception, RuntimeException, Throwable, Error는 직적 재사용하지 않는 게 좋습니다. 다른 예외들의 상위 클래스이므로 즉 여러 예외를 포괄하기 때문에 안정적으로 테스트할 수 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item73/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item73/</guid>
      <description>[아이템 73] 추상화 수준에 맞는 예외를 던져라. 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 경우 예상치 못한 예외를 접하고 당황할 수가 있습니다. 이 문제를 피하려면 상위 계층에서 저수주 예외를 잡아 자신의 추상화 수준에 맞는 예외를 던져야 합니다. 이를 예외 번역이라 부릅니다.
1 2 3 4 5 6  try { ... } catch (LowLevelException e) { // 추상화 수준에 맞게 번역.  throw new HighLevelException(..); }   AbstractSequentialList에서 수행하는 예외번역의 예시</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item74/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item74/</guid>
      <description>[아이템 74] 메서드가 던지는 모든 예외를 문서화하라. 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화를 합시다. 상위 클래스 하나로 선언하는 일은 삼가는 게 좋습니다. 어떤 예외를 호출하는지 명확하게 알 수 없고, 같은 맥락에서 다른 예외가 발생할 여지가 있을 경우 이러한 것까지 다 삼켜버릴 수 있기 때문입니다. 비검사 예외 같은 경우 메서드 선언에 throws를 넣는 건 권장하지 않습니다. 검사냐 비검사냐에 따라 API 사용자가 할 일이 달라지므로 이 둘은 확실히 구분해두는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item75/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item75/</guid>
      <description>[아이템 75] 예외 상세 메시지에 실패 관련 정보를 담으라. 스택 트레이스는 예외 객체의 toString 메서드를 호출해 얻는 문자열입니다. toString 메서드에 발생 원인에 대한 정보는 가능한 많을 수록 좋습니다. 물론 장황하지 않고 필요한 정보만 담는 것입니다. 가장 좋은 건 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담는 것입니다. 물론 보안관 관련된 정보는 유의해서 다루어야 합니다. ex) IndexOutOfBoundsException의 상세 메세지에는 범위의 최솟값, 최댓값, 범위를 벗어난 인덱스의 값을 담는 것입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item76/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item76/</guid>
      <description>[아이템 76] 가능한 한 실패 원자적으로 만들라. 여기서 말하는 실패 원자적이란 호출한 메서드가 실패하더라도 해당 객체는 호출 전 상태로 유지되는 것입니다. 가장 간단한 방법은 불변 객채로 설계하는 것입니다. 가변 객체일 경우 작업 수행 전에 유효성을 검사합는 것입니다.
1 2 3 4 5 6 7 8  public Object pop() { if (size == 0) { throw new EmptyStachException(); } Object result = el[--size]; el[size] = null; // 참조 해제  return result; }   유효성 검사하는 부분이 없어도 ArrayOutOfBoundsException을 던지지만 이는 추상화 수준에 상황에 어울리지 않습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item77/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-09/item77/</guid>
      <description>[아이템 77] 예외를 무시하지 마라. 발생할 수 있는 실수
1 2 3 4 5  try { ... } catch (IllegalArgumentException e){ }   초보 프로그래머가 할 수 있는 실수입니다. catch 블록에서 아무것도 하지 않으면 catch가 존재할 이유가 없어지는 것과 마찬가지입니다. 예외가 발생허더라도 계속 지나칠 수 있습니다. 이는 심각한 결함으로 이어질 수 있습니다. 만약 예외를 무시하기로 결정한 부분이라면 IllegalArgumentException ignored로 바꿔놓는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item78/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item78/</guid>
      <description>[아이템 78] 공유중인 가변 데이터는 동기화해 사용하라. 동기화란 특정 메서드나 블럭에 한 쓰레드가 접근했을 때, 해당 객체에 락을 걸고 다른 쓰레드가 접근하지 못하도록 하는 것이다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -&amp;gt; { int i = 0; while (!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item79/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item79/</guid>
      <description>[Itemm 79] 과도한 동기화는 피하라. 과도한 동기화는 성능을 저하시키고 교차상태에 빠뜨릴 수 있다. liveness, safety failures를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에게 양보하면 안 된다. ex) 동기화된 영역 안에서 재정의할 수 있는 메서드 호출 x, 클라이언트가 념겨준 함수 객체 호출 x 과도한 동기화는 성능을을 저하 시킨다. 가변 클래스를 작성하거든 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화 하게 하던가, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item80/</guid>
      <description>[아이템 80] 스레드보다는 실행자, 태스크, 스트림을 애용하라. Excutor Framework는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.
1 2 3  ExecutorService exec = Executors.newSingleThreadExecutor(); exec.excute(runnable); // 이 실행자에게 task를 넘김 exec.shutdown(); // graceful하게 종료 (이 작업이 실패하면 VM 자체가 종료되지 않을 것)   이 외에도 다양한 기능을 실행할 수 있다. 실행자 서비스를 사용하기에 까다로운 애플리케이션도 있는데, 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다. CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행한다 가용한 스레드가 없다면 새로 하나를 생성한다, 서버가 무거울 경우 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성해 상황을 악화시킨다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item81/</guid>
      <description>[아이템 81] wait와 notify보다는 동시성 유틸리티를 애용하라. wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하라. java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.
 실헹자 프레임워크 동시성 컬렉션 동기화 장치  동시성 컬렉션은 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 구현한다. 따라서 컬렉션에서 동기성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 속도가 느려진다. 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 건 불가능하다. 그레서 여러 기본 동작을 하나의 원자적 동작으로 묶는 &amp;lsquo;상태 의존적 수정&amp;rsquo; 메서드들이 추가되었다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item82/</guid>
      <description>[아이템 82] 스레드 안전성 수준을 문서화하라. 일반적으로 스레드 안정성이 높은 순
 불변: 외부 동기화가 필요없다. 대표적으로 String, Long, BigInteger 무조건적 스레드 안전: 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 사용해도 안전 대표적으로 ConcurrentHashMap 조건부 스레드 안전: 일부 메서드는 동시에 사용하려면 외부 동기화가 필요. Collections.synchronized 래퍼 메서드가 반환한 컬렉션이 여기 속함 스레드 비안전: 동시에 시용하려면 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야한다. ArrayList, HashMap 같은 기본 컬렉션.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item83/</guid>
      <description>[아이템 83] 지연 초기화는 신중히 사용하라. 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요햔 시점까지 늦추는 것이다. 지연 초기화는 인스턴스 생성시 초기화 비용을 줄일 수 있지만, 지연 초기화하는 필드에 접근하는 비용은 커진다. 지연 초기화를 잘못사용하면 실제로 성능이 더 느려질 수도 있다. 멀티 스레드 환경에서 지연 초기화를 하기에는 까다롭다. 지연 초기화하는 필드를 둘 이상 스레드가 공유한다면 동기화해야 한다. 일반적으로 일반적인 초기화가 지연 초기화보다 낫다.
1 2  // 인스턴스 필드를 초기화하는 일반적인 방법 private final FieldType field = computerFieldValue();   1 2 3 4 5 6 7 8 9  // 지연 초기화 - sychronized 방식 private FieldType field; private sychronized FieldType getField() { if (field == null) { field = computerFieldValue(); } return field; }   1 2 3 4 5 6 7 8  // 정적 필드용 지연 초기화 홀더 클래스 관용구 private static class FieldHolder { static final FieldType field = computerFieldValue(); } private static FieldType getField() { return FieldHolder.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-10/item84/</guid>
      <description>[아이템 84] 프로그램의 동작을 스레드 스케줄러에 기대지 말라. 구체적인 스케줄링 정책은 운영체제 마다 다를 수 있다. 따라서 이 정책에 죄지우지 되면 안 된다. 실행 가능한 스레드의 평균적인 수를 프로세스 수보다 지나치게 많아지지 않도록 하는 것이 좋은 프로그래램이다. 그래야 스케줄러가 고민할 거리가 줄기 때문이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item85/</guid>
      <description>[아이템 85] 자바 직렬화의 대안을 찾으라. 자바의 역직렬화에는 치명적인 단점이 있습니다. 신롸할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static byte[] bomb() { Set&amp;lt;Object&amp;gt; root = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;Object&amp;gt; s1 = root; Set&amp;lt;Object&amp;gt; s2 = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 100; i++) { Set&amp;lt;Object&amp;gt; t1 = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;Object&amp;gt; t2 = new HashSet&amp;lt;&amp;gt;(); t1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item86/</guid>
      <description>[아이템 86] Serializable을 구현할지는 신중히 결정하라. Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵습니다. 직렬화 당시 내부 구현 방식에 묶이고, 캡슐화가 깨지는 위험이 있습니다. 직렬화된 클래스는 고유 식별 번호를 부여받는데, serialVersionUID를 명시하지 않으면 런타임에 SHA-1을 적용하여 자동으로 클래스 안에 생성해 넣는데, 클래스의 이름, 멤버 등이 포함됩니다. 그래서 나중에 이들 중 하나를 수정한다면 UID 값도 변하여 호환성이 깨져버립니다.
1 2 3 4  // 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스용 readObjectNoData 메서드 private void readObjectNoData() throws InvalidObjectException() { throw new InvalidObjectException(&amp;#34;스트림 데이터가 필요합니다&amp;#34;); }   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item87/</guid>
      <description>[아이템 87] 커스텀 직렬화 형태를 고려해보라. 이상적인 직렬화는 물리적인 모습과 독립된 논리적인 모습을 표현해야한다. 하지만 기본 직렬화 형태는 객체가 포함한 모든 데이터와 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아낸다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class Name implements Serializable { /* * 성. null이 아니어야 함. * @serial */ private final String lastName; /* * 이름.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item88/</guid>
      <description>[아이템 88] readObject 메서드는 방어적으로 작성하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 방어적 복사를 사용하는 불변 클ㄹ스  public final class Period { private final Date start; private final Date end; /** * @param start 시작 시간 * @param end 종료 시각. 시작 시간보다 뒤어야 한다 * @throws IllegalArgumentException 시작 시간이 종료 시간보다 늦을 때 발생한다 * @throws NullPointerException start나 end가 null일시 발생 */ public Period(Date start, Date end) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item89/</guid>
      <description>[아이템 89] 인스턴스 수를 통제해야 한다면 readResolve 보단는 열거타입을 사용하라. 1 2 3 4 5 6 7  // 싱글턴 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } }   Serializable을 구현하는 순간 더이상 싱글턴이 아니다. 어떤 readObject를 사용하든 초기화될때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다. readResolve 기능을 활용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-11/item90/</guid>
      <description>[아이템 90] 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라. 직렬화 프록시 패턴을 이용하면 앞서 애기했던 단점들을 줄일 수 있다.먼저 바깥 클래스의 논리적인 상태를 표현하는 중첩 클래스를 private static으로 생성한다. 이 중첩 클래스가 바깥 클래스의 직렬화 프록시다. 이 클래스는 단순히 인스로 넘어온 인스턴스의 데이터만 복사하고 바깥 클래스와 모두 Serializable을 구현해야한다.
1 2 3 4 5 6 7 8 9 10 11  // Period 클래스용 직렬화 프록시 private static class SerializationProxy implements Serializable { private final Date start; private final Date end; SerializationProxy(Period p) { this.</description>
    </item>
    
  </channel>
</rss>
