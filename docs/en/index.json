[{"content":"아래 이미지는 만든 배너의 모습이다. UI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!\n 버튼 추가  각 banner로 바로 이동할 수 있는 버튼을 추가! 해당 banner로 이동할 때 바로 보여주는 것이 아닌, 이동 연출을 보여주었다.\n🍑 snap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void ScrollSnap(Vector2 value) //ScrollRect.onValueChanged.AddListener(ScrollSnap)에 추가해줌. { //유저가 스크롤을 조작하고 있는 경우 or 오토무브가 가능한 경우 or 배너가 움직이는 중일 경우(버튼 조작으로)  if (BannerScrollRect.isOnDown || isAbleAutoMove || isBannerMoving) { return; } if (value.x \u0026gt; points[curBannerIndex]) //오른쪽 snap  { if (value.x \u0026gt;= points[curBannerIndex] + snapRange) { var nextIndex = curBannerIndex + 1 \u0026gt;= datas.Length ? 0 : curBannerIndex + 1; MoveBannerByIndex(nextIndex);//해당인덱스로 이동  } else { MoveBannerByIndex(curBannerIndex); } } else //왼쪽 snap  { if (value.x \u0026lt;= points[curBannerIndex] - snapRange) { var prevIndex = curBannerIndex - 1 \u0026lt; 0 ? 0 : curBannerIndex - 1; MoveBannerByIndex(prevIndex); } else { MoveBannerByIndex(curBannerIndex); } } }   🍑 배너 이동 코루틴\n이전에 포스팅했던 타이머를 활용해보자!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  IEnumerator CoMoveBanner(int index) { curBannerIndex = index; indexButtons[curBannerIndex].SelectWithoutNotify(true); var timer = 0f; var startPoint = BannerScrollRect.ScrollRect.horizontalNormalizedPosition; while (timer \u0026lt; duration) //duration 동안 이동  { timer += Time.deltaTime; //스크롤 포인트 조절! lerp를 사용하여 부드럽게 이동시키자!  BannerScrollRect.ScrollRect.horizontalNormalizedPosition = Mathf.Lerp(startPoint, points[index], ease.Evaluate(timer / duration)); yield return null; } isAbleAutoMove = true;//오토무브 가능으로 변경  isBannerMoving = false;//배너 움직임이 끝났음을 알림  autoTimer = 0; //무브를 조작했다면 오토무브 타이머를 초기화 }   ","permalink":"https://qutrits.github.io/en/posts/dummy/studying15_snap/","summary":"아래 이미지는 만든 배너의 모습이다. UI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!","title":"배너를 만들어보자!"},{"content":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. \u0026lt;그림 2\u0026gt;는 \u0026lt;그림 1\u0026gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.\n👉입력 첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.\n👉출력 첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  namespace Algorithm19 { class Baekjoon2667 { static void Main(string[] args) { char house = \u0026#39;1\u0026#39;; char visitedHouse = \u0026#39;2\u0026#39;; int N = int.Parse(Console.ReadLine()!); var arr = new char[N,N]; var list = new char[N]; for (int i = 0; i \u0026lt; N; i++) { list = Console.ReadLine()!.ToCharArray(); for (int j = 0; j \u0026lt; N; j++) { arr[i,j] = list[j]; } } List\u0026lt;int\u0026gt; countList = new List\u0026lt;int\u0026gt;(); int c = 0; for (int r= 0; r \u0026lt; N; r++) { for (; c \u0026lt; N; c++) { if (arr[r, c] != house) { continue; } countList.Add(DFS(r, c)); } c = 0; } Console.WriteLine(countList.Count); countList.Sort(); for (int i = 0; i \u0026lt; countList.Count; i++) { Console.WriteLine(countList[i]); } int DFS(int r, int c) { int cnt = 0; if (arr[r, c] == house) { arr[r, c] = visitedHouse; cnt++; } //방법1  if (r + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r + 1, c] == house) //오른쪽  { cnt += DFS(r + 1, c); } if (r - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r - 1, c] == house) //왼쪽  { cnt += DFS(r - 1, c); } if (c - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r, c - 1] == house) //아래쪽  { cnt += DFS(r, c - 1); } if (c + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r, c + 1] == house) //위쪽  { cnt += DFS(r, c + 1); } //방법2  //상하좌우(4 Way) 움직임..  int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; for(int d = 0; d \u0026lt; 4; d++) // 상하좌우 탐색  { int nX = x + dx[d]; // 새로운 x좌표  int nY = y + dy[d]; // 새로운 y좌표  if(nX \u0026lt; 0 || nX \u0026gt;= N || nY \u0026lt; 0 || nY \u0026gt;= N) // Out of Bound 체크 - 맵의 경계를 넘어가나 체크하는 것이다.  { continue; } if(board[nX, nY] == house) // 새로 이동할 위치에 아파트 건물이 있고, 아직 방문하지 않은 정점이라면  { DFS(nX, nY); // 이 위치에서 DFS 호출  } } return cnt; } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm19_2667/","summary":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다.","title":"AlgorithmStudy_백준 2667"},{"content":"면접에서 받았던 퀴즈였다.\n 주사위 하나로 1~18를 같은 확률로 어떻게 하면 표현할 수 있을까?\n 면접 당시 나는 사칙연산에 빠져서 답을 도출해내지 못하였다. 하지만, 웬걸 집에가서 다시 생각해보니 바로 답이 떠오르지 않겠는가?ㅠㅠㅠ 너무 아쉽다.\n🧐 나의 해답 🧐\n 1회 주사위를 굴린다. 이때, 4 -\u0026gt; 1, 5 -\u0026gt; 2, 6 -\u0026gt; 3 으로 간주한다. 2회째 주사위를 굴린다. 첫 주사위가 1이라면, 1 ~ 6 의 값을, 2라면, 7 ~ 12의 값을, 3이었다면, 13 ~18의 값을 가질 수 있다.  1 ~ 18 사이의 모든 값은 동일한 확률로 나온다!  ","permalink":"https://qutrits.github.io/en/posts/dummy/interview1/","summary":"면접에서 받았던 퀴즈였다.\n 주사위 하나로 1~18를 같은 확률로 어떻게 하면 표현할 수 있을까?\n 면접 당시 나는 사칙연산에 빠져서 답을 도출해내지 못하였다. 하지만, 웬걸 집에가서 다시 생각해보니 바로 답이 떠오르지 않겠는가?ㅠㅠㅠ 너무 아쉽다.\n🧐 나의 해답 🧐\n 1회 주사위를 굴린다. 이때, 4 -\u0026gt; 1, 5 -\u0026gt; 2, 6 -\u0026gt; 3 으로 간주한다. 2회째 주사위를 굴린다. 첫 주사위가 1이라면, 1 ~ 6 의 값을, 2라면, 7 ~ 12의 값을, 3이었다면, 13 ~18의 값을 가질 수 있다.","title":"면접 퀴즈"},{"content":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다. 만약 없다면, 유니티는 가비지 컬렉터 작동을 시켜 메모리가 생기면 변수를 할당한다. 가비지 컬렉터 실행 후에도 메모리가 없을 경우에는 힙공간을 늘린 후 변수를 할당한다.  가비지 컬렉션이 진행될 때 무슨 일이 일어날까? 🧐  힙메모리에 있는 모든 오브젝트들을 조사. 모든 오브젝트들의 레퍼런스를 조사하여 현재 힙메모리에 있는 오브젝트가 스코프에 남아있는지 확인한다. 더 이상 스코프 안에 있지 않은 오브젝트들을 마크한다. 마크된 오브젝트를 메모리해제하여 메모리를 다시 사용할 수 있는 상태로 만든다.  가비지 컬렉터가 작동해야하는 상황, 유니티가 힙공간을 늘려야하는 상황 모두 성능의 저하를 가져온다.\n가비지 컬렉션는 언제 작동할까? 🧐  힙메모리 할당을 요청 받았을 때, 할당이 불가능한 경우.(메모리 자체의 부족 또는 메모리 단편화 상태) 가비지 컬렉터는 자동적으로 작동을 한다.(플랫폼에 따라 작동 횟수는 다양함) 강제로도 작동시킬 수 있지만 권장하지 않는다.(비용이 많이 든다!)  가비지 컬렉션의 문제점은? 🧐  비용이 많이 든다.(어떤 메모리를 청소해야할지 찾는 데에 시간이 듬) 어떠한 타이밍에 실행될지 모른다.(ex. cpu가 게임에서 중요한 부분을 작업하는데 가비지 컬렉션이 일어나면 아무리 작은 추가 오버헤드일지라도 프레임 드랍을 일으킬 수 있다.) 메모리 단편화 문제!  가비지를 줄이려면? 🧐  캐싱: 반복적으로 호출하여 할당하지만 그 결과가 버려지는 오브젝트들을 캐싱해두고 다시 사용하자. 자주 사용되는 함수에서 힙 할당을 자제하자.(update 같은 함수) Collection사용시 Clear()해서 재사용하기.(캐싱해서 사용해라~ new로 새로 만들지 말고!) 런타임에 많은 오브젝트들을 생성하고 파괴하기 보다는 오브젝트 풀링 이용. string 사용에 주의하자! immutable, reference type 이기 때문에 string으로 조작할 때마다 이전 string은 가비지가 됨. Debug.Log() 는 디버깅할 상황이 끝나면 바로바로 지워주자! GameObject.name, GameObject.tag 같은 경우는 새로운 string을 만들어 return 해주기 때문에 GameObject.CompareTag()같은 함수를 대신 적극 이용하는 것이 좋다. 코루틴을 사용할때도 유의해야한다. yield return 시 new 키워드를 반복사용해야한다면 캐싱해놓고 사용하자.  이외에도 더 많은 줄일 수 있는 방법들이 있다. 참고 링크\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying14_gc/","summary":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다.","title":"GarbageCollection: 가비지 컬렉션"},{"content":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!  if (timer \u0026gt;= time) { break; } //시간을 더해주자!  timer += Time.deltaTime; yield return null; //남은 시간을 보내주기  onValueChanged(time - timer); } //타이머가 끝나면 코루틴을 null  curTimer = null; } }   💚 deltaTime 사용 이유!\n 지난 프레임이 완료되는 데 까지 걸린 시간을 나타내며, 단위는 초를 사용합니다.(읽기전용) 사용자의 프레임 률(frame rate)을 독립적으로 적용하기 위해서 사용합니다.\n 즉! 사용자의 각자 프레임률이 다르기 때문에 프레임 카운트로 타이머를 만든다면 각 사용자의 타이머는 시간이 모두 다르다. 하지만 deltaTime을 쓴다면, 같은 결과값을 얻을 수 있다!\n여기서, 매 프레임마다 실행되는 update와 달리 coroutine을 사용했는데 내용이 적용이 될까? 라는 의문이 들 수 있다. yield return null 을 사용함으로 update바로 다음에 실행이 되도록 하였다! 즉, update에서 사용하는 것과 동일하게 사용이 가능하다.\n🍑 스킬아이콘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  public class SpellIcon : MonoBehaviour { //연출에 사용할 커브! [SerializeField] private AnimationCurve ease; //스킬 아이콘 이미지  private Image img_icon; //쿨타임이 돌 때 이미지(딤드)  private Image img_cooltime; //쿨타임을 표시해 줄 텍스트  private Text txt_timer; //타이머를 가지고 있자!  private Timer timer; //임시 쿨타임 적용  private int cooltime = 5; private void Awake() { foreach (var img in GetComponentsInChildren\u0026lt;Image\u0026gt;()) { if (img.name == \u0026#34;Image_Spell\u0026#34;) { img_icon = img; } else if (img.name == \u0026#34;Image_CoolTime\u0026#34;) { img_cooltime = img; } } var btn = img_icon.gameObject.AddComponent\u0026lt;Button\u0026gt;(); btn.onClick.AddListener(OnClickSpell); timer = GetComponent\u0026lt;Timer\u0026gt;(); txt_timer = GetComponentInChildren\u0026lt;Text\u0026gt;(); } //바깥에서 불러줘야해!  //useAble : 바로 사용이 가능한지?  public void Initialize(Sprite sprite, int cooltime, bool useAble = true) { img_icon.sprite = sprite; this.cooltime = cooltime; //바로사용이 불가능하다면 쿨타임을 실행!  OnTimeChanged(useAble ? cooltime : 0); } void UseSpell() { img_cooltime.raycastTarget = true; timer.StartTimer(cooltime, OnTimeChanged); } void OnClickSpell() { //어디론가 보내서 스킬을 발동되도록 해야겠지 ?  Debug.Log(\u0026#34;아 스킬 발동ㅋ\u0026#34;); ClickAnimation();//연출!  UseSpell(); } void ClickAnimation() { //클릭시 커졌다가 다시 돌아오는 핑퐁형태의 연출을 추가!  transform.Scale(Vector3.one, Vector3.one * 1.1f, 0.1f).SetEase(ease,true).Play(); } //타임이 변경될 때 마다 업데이트를 시켜줌  void OnTimeChanged(float time) { UpdateCooltimeImage(time); UpdateTimerText(time); } void UpdateCooltimeImage(float time) { if (time \u0026lt;= 0) { //쿨타임이 끝났으니 아이콘을 누를 수 있도록 해당 이미지를 raycastTarget을 꺼줌.  img_cooltime.raycastTarget = false; } if (cooltime \u0026gt; 0) { img_cooltime.fillAmount = time / cooltime; } else { img_cooltime.fillAmount = 0; } } void UpdateTimerText(float time) { txt_timer.text = time \u0026lt;= 0 ? string.Empty : txt_timer.text = Math.Ceiling(time).ToString(); } }   스킬 아이콘을 초기화해주고 정보를 넣어주는 것은 원래 해당 클래스 바깥에서 관리를 해주어야 할 것이다. 이 스킬 아이콘들의 상태를 관리하고 이벤트들을 실제로 사용하는 곳으로 전달하는 역할의 매니저 클래스가 필요하다. 다음에 이 클래스를 관리하는 클래스도 추가해보겠다. 이 클래스는 실 데이터(스킬의 데미지, 타겟, 효과 등\u0026hellip;)를 다루거나 그 데이터를 기반으로 행위를 하는 것보다 사용자의 눈에 보여지는 부분만 처리하기 위해 존재한다.(UI적 부분만)\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying13_timer/","summary":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!","title":"타이머를 이용해 스킬아이콘을 만들어보자!"},{"content":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!  { if (pingpong)//핑퐁을 한다면  { Keyframe[] keyframes = new Keyframe[ease.length]; //애니메이션 커브의 키 프레임만큼 키프레임 배열 생성  for (int i = 0; i \u0026lt; ease.length; i++) { //일대일 매칭을 해서  keyframes[i] = ease.keys[i]; //정해진 기간내에 from으로 와야함.  //반절은 to로 반절은 from로 가야하기때문에 2로 나누어 줌!  keyframes[i].time = keyframes[i].time / 2; } //새로운 커브를 생성해 이전 ease와 교체  ease = new AnimationCurve(keyframes); //핑퐁으로 모드를 변경!  ease.postWrapMode = WrapMode.PingPong; } tween.Ease = ease; } else { Debug.Log(\u0026#34;tween is playing\u0026#34;); } return tween; }   💚 ease.Evaluate(time / duration) 를 통해서 총 애니메이션 기간에 대한 현재 애니메이션 타임의 값을 ease에서 얻을 수 있다. 이 값을 대상이 Transform(position, scale, rotate)이든지 MaskAbleGraphic(color, alpha), CanvasGroup(alpha)이든지 간에 값을 정해줄 수 있다.\n나중에 애니메이션커브만 따로 포스팅을 해보겠다!\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying12_tweenmaking/","summary":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!","title":"Tween 만들기 프로젝트 근황"},{"content":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다. 즉, 아무렂 직업이 없는 일반 오크(부모클래스)도 존재할 수 있고, 이 오크를 기반으로 다양한 직업을 가진 오크(자식클래스)도 존재할 수 있다.\n🍑 위의 내용을 바탕으로 코드를 만들어 보자! 🍑 일반클래스, 추상클래스, 인터페이스 모두 활용해보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  public abstract class Monster //몬스터라는 분류! { private int maxHp; private int maxMp; private int hp; private int mp; private bool isAbleSkill; public bool IsAbleSkill { get =\u0026gt; mp \u0026gt; 0; private set =\u0026gt; isAbleSkill = value; } private bool IsAlive=\u0026gt; hp \u0026gt; 0; public int Hp { get =\u0026gt; hp; set { var _hp = hp + value; if (_hp \u0026gt; maxHp) { hp = maxHp; } else if (_hp \u0026lt;= 0) { Die(); } else { hp = _hp; } } } public int Mp { get =\u0026gt; mp; set { var _mp = mp + value; if (_mp \u0026gt; maxMp) { mp = maxMp; } else if (_mp \u0026lt;= 0) { mp = 0; } else { mp = _mp; } } } protected Monster(int maxHp, int maxMp)//abstract 클래스의 생성자는 항상 protected로!  { this.maxHp = maxHp; this.maxMp = maxMp; hp = maxHp; mp = maxMp; } public abstract void UseSkill(); public abstract void Die(); public void SetEnableUseSkill(bool able) { isAbleSkill = able; } } public class Orc : Monster { public override void UseSkill() { if (IsAbleSkill) { Skill(); } } public Orc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected virtual void Skill() { Console.WriteLine(\u0026#34;일반오크 스킬 발동!\u0026#34;); } public override void Die() { Console.WriteLine(\u0026#34;오크 죽음!\u0026#34;); } } public class WizardOrc : Orc, IFly { public WizardOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() //부모의 함수를 오버라이딩 하여 자신에게 알맞은 함수를 실행함  { Console.WriteLine(\u0026#34;마법사 오크 스킬 발동!\u0026#34;); } public void Fly() { Console.WriteLine(\u0026#34;휘익~ 마법사 오크 난다!\u0026#34;); } } public class KnightOrc : Orc { public KnightOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;전사오크 스킬 발동!\u0026#34;); } } public class ArcherOrc : Orc { public ArcherOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;궁수오크 스킬 발동!\u0026#34;); } }   상속의 특징은? 🧐  자식클래스가 부모클래스의 필드와 메소드를 모두 가지고 있다. 부모클래스에서 private으로 선언되어있는 요소들은 자식클래스라도 접근이 불가능하다.(가지고는 있음!) 부모클래스에서 protected로 선언되어있는 요소는 자식클래스만 접근이 가능하다. 부모클래스이 메소드를 virtual/override 를 통해 자식클래스에서 재정의 할 수 있다. interface를 제외한 모든 상속은 다중상속이 불가능하다.  ","permalink":"https://qutrits.github.io/en/posts/dummy/studying11_inheritance/","summary":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다.","title":"inheritance: 상속"},{"content":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다. 🍑 위의 내용을 추가로 코드를 수정해보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public abstract class Animal//동물이라는 카테고리를 표현 { private bool isAlive = true;//추상클래스는 필드를 가질 수 있다.  public abstract void Eat();//추상메소드: 자식클래스에서 모두 구현을 해주어야함!  public virtual void Die()//일반 메소드: 추상클래스는 일반 메소드 또한 가질 수 있다.  { isAlive = false; } } public abstract class Birds : Animal//동물이라는 카테고리 속 조류라는 카테고리 { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly//조류에 속하는 참새 객체 { public Sparrow(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;참새 쌀알 먹는다. 콕콕!\u0026#34;); } } public class Parrot : Birds, IFly//조류에 속하는 앵무새 객체 { public Parrot(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;츄릅~ 앵무새 메뚜기 먹는다!\u0026#34;); } }   abstract class(추상클래스)의 특징은? 🧐  클래스 안에 추상메소드가 하나라도 존재한다면, 그 클래스는 반드시 추상클래스여야한다. 추상클래스: abstract class [\u0026quot;클래스 이름\u0026quot;], 추상메소드: abstract [\u0026quot;반환타입\u0026quot;] [\u0026quot;메소드 이름\u0026quot;]( [\u0026quot;파라미터\u0026quot;] )로 표현한다. 추상메소드는 내부가 구현되지않은 상태여야한다. (이전에 포스팅했던 인터페이스가 추상메소드만으로만 이루어진 것) 접근한정자를 정해주지않으면 private 디폴트 값이다. 필드와 일반메소드 모두 가지고 있을 수 있다.(인터페이스와 가장 큰 차이점 중 하나) 다른 일반 클래스와 마찮가지로 다중상속이 불가능하다. 인터페이스와 마찮가지로 인스턴스가 불가능하다.  ** 다음 포스팅은 일반 클래스와 상속에 대해서 다루겠다!\n","permalink":"https://qutrits.github.io/en/posts/dummy/stuying10_abstract/","summary":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다.","title":"abstract class: 추상클래스"},{"content":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시 만약 조류라는 클래스가 있다고 하자. 이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다. 하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).\n이런 경우에 사용해야 할 것이 interface이다. 즉, 인터페이스는 어떠한 기능을 수행할 수 있는지 알려주는 역할을 하는 것이다. Can Do!\n🍑 위의 설명을 코드로 만들어 보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public interface IFly { void Fly(); } public abstract class Birds : Animal { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public Sparrow(Beak beak) : base(beak) { } } public class Parrot : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public Parrot(Beak beak) : base(beak) { } } public class Penguin : Birds, ISwim { public void Swim() { Console.WriteLine(\u0026#34;슈슉~ 펭귄 수영한다~\u0026#34;); } public Penguin(Beak beak) : base(beak) { } } public class SugarGlider : Mammalia, IFly { public void Fly() { Console.WriteLine(\u0026#34;슝~ 슈가 글라이더 난다~\u0026#34;); } }   interface(인터페이스)의 특징은? 🧐  내부를 구체화 하지않은 메소드만으로 이루워져있다. 인스턴스가 불가능하다.: 다른 일반 클래스처럼 new로 인스턴스화 할 수 없다. 반드시 상속을 통해 사용해야한다. 다중 상속이 가능하다! 인터페이스를 상속한 클래스는 반드시 인터페이스 안의 모든 메소드를 구체화 해야한다. 접근 한정자가 항상 public이다. 내부 메소드 또한 public으로 구현이된다.  ** 다음 포스팅은 abstract class에 대해서 공부해보도록 하겠당~\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying9_interface/","summary":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시 만약 조류라는 클래스가 있다고 하자. 이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다. 하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).","title":"interface: 인터페이스"},{"content":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱 그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.  단점   답이 아닌 경로가 깊다면 해를 구하는 데에 오래 걸린다. 왜?: 다시 돌아와서 탐색해야하기 때문에.  💚 딱히 장단점은 중요하지 않은 것 같다. 최단 경로 찾기에는 어쨋든 최적해를 보장해주는 BFS를 써야하지않을까? DFS는 SCC를 찾는 데 사용한다고 한다.\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying8_bfs_dfs2/","summary":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱 그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(2)"},{"content":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].Add(v);//간선으로 연결된 정점들을 모두 추가  } }   BFS를 알아보자 🧐  BFS(Breadth First Search)는 너비우선탐색으로 어떠한 정점으로부터 인접한 정점을 먼저 방문하는 탐색 알고리즘이다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void BFS(int v)//시작 정점 { Queue\u0026lt;int\u0026gt; queue_bfs = new Queue\u0026lt;int\u0026gt;(); queue_bfs.Enqueue(v); visited.Add(v);//방문함!  while (queue_bfs.Count \u0026gt; 0)//큐의 갯수가 1개 이상일 때,  { var w = queue_bfs.Dequeue();//방문한 정점을 빼면서  for (int i = 0; i \u0026lt; ve[w].Count; i++)//인접한 정점들을 탐색  { if (!visited.Contains(ve[w][i]))//방문하지 않은 정점이 있다면  { queue_bfs.Enqueue(ve[w][i]); visited.Add(ve[w][i]);//방문!  } } } }   DFS를 알아보자 🧐  DFS(Depth First Search)는 깊이우선탐색으로   시작 정점으로 부터 인접한 정점 중 한 정점을 방문한다. 그 정점을 기준으로 1을 반복한다. 더 이상 인접한 정점이 없으면, 다시 이전 정점으로 돌아간다(백트래킹). 모든 정점을 방문할 때까지 1~3을 반복한다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void DFS(int v)//시작 정점  { if (visited.Contains(v)) //이미 방문한 곳이라면 return  { return; } visited.Add(v);//방문한 정점추가  for (int i = 0; i \u0026lt; ve[v].Count; i++) { if (!visited.Contains(ve[v][i]))//방문하지 않은 인접 정점을 방문하러가자!  { DFS(ve[v][i]); } } }```   ","permalink":"https://qutrits.github.io/en/posts/dummy/studying7_bfs_dfs/","summary":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(1)"},{"content":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)\n이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \u0026ldquo;0\u0026rdquo; 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.\n정수가 \u0026ldquo;0\u0026quot;일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n👉출력 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  using System; using System.Collections.Generic; namespace Algorithm15 { class Beakjoon10773 { static void Main(string[] args) { var k = int.Parse(Console.ReadLine()!); var stack = new Stack\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; k; i++) { var input = int.Parse(Console.ReadLine()!); if (input == 0)//0이 들어오면 이전 것을 pop  { stack.Pop(); } else { stack.Push(input);//그렇지않다면 push  } } int sum = 0; foreach (var s in stack) { sum += s; } Console.WriteLine(sum); } } }   후입선출인 Stack의 개념을 이용한 문제였다. 너무 쉬운 문제를 선택해버렸을지도..?ㅎㅎ\n문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm15_10773/","summary":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)","title":"AlgorithmStudy_백준 10773"},{"content":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다. 하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다. 그리고 그건 불가능한 게 맞다. 하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.   💚2 - 예시\n1 2 3 4 5 6 7 8 9 10  Shader \u0026#34;Custom/TestShader\u0026#34; { Properties { [PerRendererData]_Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } }   변경점 적용.  💚3 - 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  using UnityEngine; public class MaterialColorChanger : MonoBehaviour { public Color toColor; private Renderer _renderer; public Renderer Renderer { get { if (_renderer == null) { _renderer = GetComponent\u0026lt;Renderer\u0026gt;(); } return _renderer; } } public void ChangeColor() //material의 컬러를 직접적으로 바꾸는 방법: 새로운 material instance가 생성됨.  { Renderer.material.color = toColor; } public void ChangeColorWithPropertyBlock()//property의 값을 바꾸는 방법. 하나의 material을 사용하면서 서로 다른 값을 가질 수 있음.  { var propertyBlock = new MaterialPropertyBlock(); Renderer.GetPropertyBlock(propertyBlock); propertyBlock.SetColor(\u0026#34;_Color\u0026#34;, toColor); Renderer.SetPropertyBlock(propertyBlock); } }   차이점 확인 🧐 같은 머티리얼을 공유하는 4개의 오브젝트들을 미리 static batching이 되도록 설정을 해놓은 상태입니다.\n 렌더러에서 머티리얼의 값을 직접적으로 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 머티리얼을 사용하기 때문. 서로 다른 머티리얼을 사용한다는 것은 런타임 중에 새로운 머티리얼을 인스턴스했다는 것.  프로퍼티의 값을 통해 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 프로퍼티 값을 가지고 있기 때문.(즉 배칭을 유지하면서 컬러를 바꾸는 것은 불가능) 하나의 공유된 머티리얼을 사용하지만 각자 다른 프로퍼티 값을 가지고 있다는 것.   하지만 같은 프로퍼티 값을 가지고 있는 오브젝트들은 배칭이 유지된다.   ⚠️주의⚠️\n[PerRendererData]을 쓰지 않을 경우: 함수들은 사용이 가능하지만 내부적으로 새 머티리얼 인스턴스 하기 때문에 결국은 1번의 방법과 같은 결과를 낳는다.\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying6_drawcall3/","summary":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다. 하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다. 그리고 그건 불가능한 게 맞다. 하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.","title":"Draw Call: 드로우콜(3)"},{"content":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.\n👉입력 입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 테스트 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 64 이상 1,000,000 이하인 하나의 정수로 주어진다.\n👉출력 출력은 표준출력을 사용한다. 하나의 테스트 데이터에 대한 답을 하나의 줄에 출력한다. 각 테스트 데이터에 대해, 주어진 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하여 회문이 될 수 있다면 1을, 그렇지 않다면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections.Generic; namespace Algorithm14 { class Baekjoon11068 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var arr = new int[t]; for (int i = 0; i \u0026lt; t; i++) { arr[i] = int.Parse(Console.ReadLine()!); } for (int i = 0; i \u0026lt; t; i++) { int result = 0; for (int j = 2; j \u0026lt;= 64; j++) { var convert = ConvertJ(arr[i], j); result = Check(convert); if (result == 1) { break; } } Console.WriteLine(result); } int Check(List\u0026lt;int\u0026gt; list)//회문인지 체크  { for (int i = 0; i \u0026lt; list.Count / 2; i++) { if (list[i] != list[list.Count - i - 1]) { return 0; } } return 1; } List\u0026lt;int\u0026gt; ConvertJ(int value, int j)//진법 변환(사실 여기서 뒤집어주어야 알맞은 값이 나오지만 사실 이 문제에서는 상관이없기때문에 뒤집지않았다.)  { List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); while (value / j \u0026gt; 0) { list.Add(value % j); value /= j; } list.Add(value); return list; } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm14_11068/","summary":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.","title":"AlgorithmStudy_백준 11068"},{"content":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적. 같은 머티리얼을 사용하는 메쉬들을 렌더링할 때 드로우콜을 줄일 수 있다.(동일한 머티리얼 인스턴스여야 함) 배경 같은 요소(트랜스폼 등이 바뀌지 않는 오브젝트)에 적용해주기에 적합함.  ⚠️주의⚠️\n메모리가 추가로 필요함. 해당되는 오브젝트들은 처음부터 Scene에 존재해야 함. 동일한 머터리얼을 사용할 지라도 스크립트에서 Renderer.material.color = Color.red;처럼 머터리얼의 속성을 변경한다면 복사본이 생성되기 때문에 적용되지않는다(Renderer.sharedMaterial사용으로 해결가능).\nDynamic Batching: Static 플래그가 체크되어있지않은 모든 오브젝트에 적용 됨.   매 프레임, 오브젝트들의 버텍스 정보를 합쳐 버텍스 버퍼와 인덱스 버퍼에 담아 GPU가 렌더링 함. 따라서 매 프레임마다 오버헤드가 발생. 그러나 드로우콜을 줄임으로 전체적인 성능 향상.  ⚠️주의⚠️\nSkinned Mesh에는 적용이 되지않음.\n버텍스가 너무 많은 메쉬에는 적용이 되지않음.\n2D 환경에서는 드로우콜을 어떻게 줄이나요? 🧐  Sprite Mode: Multiple 사용. Sprite Atlas 이용.  참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying5_drawcall2/","summary":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적.","title":"Draw Call: 드로우콜(2)"},{"content":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재. CPU 메모리에서 GPU 메모리로 위의 정보 데이터들의 복사가 이루워짐.(게임 수행 내내 데이터는 메모리에 상주) GPU에는 렌더링 할 것의 상태 정보를 담는 테이블이 존재.(Render States: GPU 메모리의 데이터 위치 정보 보유) 새로운 오브젝트를 그릴 때 마다 상태 변경 CPU -\u0026gt; GPU로 상태 변경 명령을 내림.(변경이 필요한 부분만) CPU -\u0026gt; GPU로 상태 변경 명령(render state change) + 렌더 명령(Draw Primitive Call(DP Call)) = 드로우콜 CPU -\u0026gt; 커맨드 버퍼(Command Buffer) -\u0026gt; GPU 순으로 명령이 이루워짐.  Draw Call이 많으면 무엇이 문제일까? 🧐  명령을 GPU에서 사용하는 신호로 변환해야하기 때문에 CPU에 부담이 된다.(CPU 오버헤드)  어떻게 해야할까? 🧐  렌더링에 관련된 작업들을 별도의 쓰레드에서 수행하게한다.(Multithreaded Rendering)  드로우콜을 줄인다.  ⚠️주의⚠️\n드로우콜을 줄이는 데에는 텍스쳐의 크기 또는 폴리곤의 수를 줄이는 것과 관련이 없다!\nDraw Call은 어떻게 발생되는 걸까? 🧐 보통 오브젝트를 그릴 때 Mesh가 1개, Material이 1개일 경우 드로우콜이 한 번 일어난다.\n Mesh가 여러 개인 경우 Material이 여러 개인 경우 Shader에 따라서\u0026hellip;   ⚠️주의⚠️\n수많은 상태 변경들을 포함하기 때문에 드로우콜의 비용은 개당으로 계산하기 어렵다.\n참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://qutrits.github.io/en/posts/dummy/studying4_drawcall1/","summary":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재.","title":"Draw Call: 드로우콜(1)"},{"content":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.\n (c++ 의 템플릿과 비슷!)\n왜 사용하는거야? 🧐  기능이 같은 클래스를 타입만 바꾸어 새롭게 구현할 필요없이 Generic class로 구현하면 여러 타입으로 하나의 클래스를 활용할 수 있다. 대표적 예시로 List\u0026lt;T\u0026gt;가 있다.  어떻게 사용해야해? 🧐  public class [ClassName]\u0026lt;T\u0026gt; 로 선언. 여러개의 타입을 사용하고 싶을 때는 \u0026lt;T1, T2 ...\u0026gt; 이런 식으로 나열하면 된다. 제네릭 타입에 제약을 두고 싶을 경우 where T : [제약조건]과 같이 마지막에 조건을 붙인다.  ⚠️주의⚠️ 만약 제네릭 클래스가 MonoBehaviour를 상속하고 있을 때, GameObject에 AddComponent를 바로 할 경우 null이 된다. 각 제네릭 타입마다 class를 새로 생성 후 가능하다.\n⛔ 옳지않은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  using System; using UnityEngine; namespace MyTween { public class Tween\u0026lt;T1, T2\u0026gt;: MonoBehaviour { private T1 target; private T2 v_end; } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { Tween\u0026lt;Transform, Vector3\u0026gt; tween = tr.gameObject.AddComponent\u0026lt;Tween\u0026lt;Transform, Vector3\u0026gt;\u0026gt;();//null 반환!!  return tween; } } }   💚 옳은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System; using UnityEngine; namespace MyTween { public class TweenVector3 : Tween\u0026lt;Transform, Vector3\u0026gt; { } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { TweenVector3 tween = tr.gameObject.AddComponent\u0026lt;TweenVector3\u0026gt;();//성공적인 반환!!  return tween; } } }   ","permalink":"https://qutrits.github.io/en/posts/dummy/studying3_generic/","summary":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.","title":"Generic: 제너릭 클래스"},{"content":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 \u0026lsquo;-\u0026rsquo;, \u0026lsquo;=\u0026lsquo;로만 이루어져 있다.\n단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.\n👉출력 입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  using System; using System.Collections.Generic; using System.Text; namespace Algorithm13 { class Baekjoon2941 { static void Main(string[] args) { List\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt; {\u0026#34;c=\u0026#34;, \u0026#34;c-\u0026#34;, \u0026#34;dz=\u0026#34;, \u0026#34;d-\u0026#34;, \u0026#34;lj\u0026#34;, \u0026#34;nj\u0026#34;, \u0026#34;s=\u0026#34;, \u0026#34;z=\u0026#34;}; var input = new StringBuilder(Console.ReadLine()); foreach (var s in list) { input.Replace(s, \u0026#34;*\u0026#34;);//해당되는 문자열을 다른 문자로 변경  } Console.WriteLine(input.Length);//문자열의 길이 출력  } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm13/","summary":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다.","title":"AlgorithmStudy_백준 2941"},{"content":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, \u0026hellip;\nn을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\n10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n👉입력 입력은 없다.\n👉출력 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  using System; using System.Linq; namespace Algorithm12 { class Baekjoon4673 { static void Main(string[] args) { var arr = new bool[10000]; //생성자가 있는 지 없는 지 체크해주는 배열!  for (int i = 0; i \u0026lt; arr.Length; i++) { var n = i + 1; //실제 체크해야 하는 수는 인덱스 보다 1 더 큼.  if (arr[i] == false) //만약 생성자가 없다면  { Console.WriteLine(n);//출력  } var list = n.ToString().ToArray();//수를 array 로 변환  foreach (var num in list) { n += num - \u0026#39;0\u0026#39;;//수에 각 자리 수를 더함  } if (n - 1 \u0026lt; arr.Length)//만약 인덱스가 arr의 길이보다 작을 경우에는  { arr[n - 1] = true;//생성자가 있다고 true 로 변경하기  } } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm12/","summary":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다.","title":"AlgorithmStudy_백준 4673"},{"content":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야? 🧐  인스턴스 메서드를 추가하려면 해당 클래스 안에 메서드를 추가해야한다. 하지만 접근이 불가한 클래스라면 ??? Extenstion Method를 사용하자!  어떻게 사용해야해? 🧐  static class static method public Extenstion Method는 첫번째 파라미터로 반드시 클래스명을 지정해야 함.public static void Function(this T parm) 이 파라미터 앞에 반드시 this 키워드를 추가할 것! 만약 Extenstion Method 사용 후 또 다른 확장 메소드를 쓰고 싶을 시 this로 들어왔던 첫 파라미터를 반환 해주면 된다.  🍑 예시: tween 만들기 프로젝트에 일부를 이용했다..ㅎㅎ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  using System.Collections; using UnityEngine; namespace MyTween { public static class Tween { public static Transform Move(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } public static Transform Scale(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using MyTween; public class ButtonDirecting : MonoBehaviour, IPointerDownHandler, IPointerUpHandler { public AnimationCurve ease; public Vector2 toSize = Vector2.one; public float duration; private bool isTweening = false; private event Action onClick; private Vector2 fromSize; public void OnClick() { transform.Move(Vector3.one, 1f, ease).Scale(Vector3.one, 1f); } }   ","permalink":"https://qutrits.github.io/en/posts/dummy/studying2/","summary":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야?","title":"Extenstion Method: 확장 메서드"},{"content":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다. 그림에서 흐릿하게 보이는 모든 부분은 원래 문제와 다르지 않다.\n빈 칸에 들어갈 두 자연수가 주어졌을 때 문제를 해결하는 프로그램을 작성하자.\n👉입력 첫 번째 줄에 테스트 케이스의 수 T (1 ≤ T ≤ 50 000)가 주어진다. 이후 T개의 테스트 케이스가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있으며, 각 줄에는 두 개의 정수 A와 B (1 ≤ A, B ≤ 1 023, A ≠ B)가 공백을 사이로 두고 주어진다. 이는 첫 번째 빈 칸에는 A를, 두 번째 빈 칸에는 B를 넣었을 때 답을 구하라는 의미이다\n👉출력 각 테스트 케이스에 대해 답을 한 줄에 하나씩 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm11 { class Baekjoon13116 { static void Main(string[] args) { int tCount = int.Parse(Console.ReadLine()!); var tlist = new List\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; tCount; i++) { var input = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); tlist.AddRange(input); } for (int i = 0; i \u0026lt; tCount; i++) { int n1 = tlist[2 * i]; int n2 = tlist[2 * i + 1]; while (n1 != n2) { while (n1 \u0026lt; n2) //n2가 n1보다 크지 않을 때까지  { n2 /= 2; } if (n1 == n2) //같다면 break;  { break; } n1 /= 2; //n1이 n2보다 크지 않을 때까지  } Console.WriteLine(n1 * 10); } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm11/","summary":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다.","title":"AlgorithmStudy_백준 13116"},{"content":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.\n👉출력 첫째 줄에 정답을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm10 { class Baekjon1541 { static void Main(string[] args) { var op = new char[] {\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;}; var input = Console.ReadLine(); var opList = input!.ToCharArray().Where(a =\u0026gt; a is \u0026#39;+\u0026#39; or \u0026#39;-\u0026#39;).ToArray(); var nList = input!.Split(op).Select(int.Parse).ToArray();//연산자를 기준으로 SPLIT  if (nList.Length == 1) //수 하나만 들어왔을 경우(연산자가 없는 경우)  { Console.WriteLine(nList[0]); return; } int re = nList[0]; List\u0026lt;int\u0026gt; results = new List\u0026lt;int\u0026gt;();//결과값들을 저장해 놓을 공간(-기준으로 끊어 +연산한 값들)  for (int i = 0; i \u0026lt; opList.Length; i++) { if (opList[i] == \u0026#39;+\u0026#39;) { re += nList[i + 1]; } else { results.Add(re);//-를 만나기 전까지 더한 수의 합을 ADD  re = nList[i + 1];// -를 만난 후 다음 수  } if (i == opList.Length - 1)//다음 연산자가 없을 경우  { results.Add(re); } } var result = results[0]; for (int i = 1; i \u0026lt; results.Count; i++) { result -= results[i];//처음 값에서 나머지 값을 모두 빼줌  } Console.WriteLine(result); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm10/","summary":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다.","title":"AlgorithmStudy_백준 1541"},{"content":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","permalink":"https://qutrits.github.io/en/posts/dummy/studying1/","summary":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","title":"Studying_복잡도"},{"content":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)\n👉출력 각 테스트 케이스마다 P(N)을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  using System; using System.Linq; namespace Algorithm9 { class Baekjoon9461 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var n = new int[t];//n 수열에서 뽑아 출력해야하는 n번째 수들의 배열  for (int i = 0; i \u0026lt; t; i++) { n[i] = int.Parse(Console.ReadLine()!); } var list = n.ToList(); list.Sort(); var max = list[t - 1];//입력 중 가장 큰 숫자  var padovan = new long[max]; padovan[0] = 1; padovan[1] = 1; padovan[2] = 1; while (padovan[^1] == 0) { for (int i = 3; i \u0026lt; max; i++)//입력된 가장 큰 수 번째까지 수열을 구한다.  { if (padovan[i] != 0) { continue; } padovan[i] = padovan[i - 3] + padovan[i - 2]; //(규칙) =\u0026gt; i번째는 i-3번째 + i-2번째  } } var result = new long[t];//결과값을 담을 배열  for (int i = 0; i \u0026lt; t; i++) { result[i] = padovan[n[i] - 1];//결과값의 배열에 n값의 순서대로 수열의 값을 대입  } Console.WriteLine(String.Join(\u0026#34;\\n\u0026#34;, result)); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm9/","summary":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 9461"},{"content":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\n알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\n그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\n그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만\u0026hellip; (막은데에는 이유가 있을거라고 생각하고\u0026hellip;다른 방법을 선택!)\n그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode! 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.\n 여기서 snippet이란 재사용이 가능한 소스코드이다. 우리가 작성하는 content안에서 이 Shortcode를 불러옴으로서 원하는 기능을 수행할 수 있게 해준다.\n {{\u0026lt; Shortcode Parmeters \u0026gt;}} 형식을 따라 MarkDown에서 사용이 가능하다! html 코드들을 적용 시킬 수 있다!  자세한 설명\nShortcode를 이용해 Text에 Color 입히기 🎨   layout 폴더 아래 shortcodes라는 이름으로 폴더 생성!\n  자신이 이 Shortcode를 부를 때 사용할 이름으로 [Name].html 파일 생성! (내 경우 이름을 color라고 지정)\n  \u0026lt;span style=color:{{ .Get \u0026quot;color\u0026quot; }}\u0026gt;{{ .Get \u0026quot;text\u0026quot; }}\u0026lt;/span\u0026gt;  작성!\n  content를 만들 때 색깔을 입히고 싶은 곳에 {{\u0026lt; [Name] color=\u0026#34;[Color]\u0026#34; text=\u0026#34;[Text]\u0026#34; \u0026gt;}} 요로코롬 Shortcode를 호출하고 적용!\n  처음에는 이해하기 어려웠는데 Unity에서 쓰는 Component랑 비슷하다고 생각하니 개념에 좀 더 쉽게 다가갈 수 있었다.(어떤 오브젝트에게 어떠한 일을 시키고 싶을 때 Component를 추가하는 것 처럼?)\n","permalink":"https://qutrits.github.io/en/posts/dummy/markdown1/","summary":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\n알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\n그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\n그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만\u0026hellip; (막은데에는 이유가 있을거라고 생각하고\u0026hellip;다른 방법을 선택!)\n그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode! 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.","title":"Hugo와 MarkDown: Text Color"},{"content":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } //알파벳 순으로 정렬  var list = words.OrderBy(x =\u0026gt; x); //길이 순으로 정렬  var result = list.OrderBy(x =\u0026gt; x.Length); Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   😿 풀이 2 시간초과로 맞히지 못한 Quick Sort를 이용한 풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  using System; using System.Collections.Generic; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } int left = 0; int right = words.Count - 1; Sort(left, right); void Sort(int _left, int _right) { if (_left \u0026gt;= _right) { return; } var pivot = Divide(_left, _right); Sort(_left, pivot - 1); Sort(pivot + 1, _right); } int Divide(int _left, int _right) { int _pivot = _left; _left++; while (true) { if (words[_pivot].Length \u0026gt;= words[_left].Length) { if (words[_pivot].Length == words[_left].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026lt; words[_left][i])//피봇의 알파벳이 우선일 경우  { break; } else if(words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { _left++;//left를 한 칸 뒤로 옮기기  break; } } } else//피봇의 값이 왼쪽의 값보다 길 경우  { _left++;//left를 한 칸 옮기기  } } if (words[_pivot].Length \u0026lt;= words[_right].Length) { if (words[_pivot].Length == words[_right].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { break; } else if (words[_pivot][i] \u0026lt; words[_right][i])//피봇의 알파벳이 우선일 경우  { _right--;//right를 한 칸 앞으로 옮기기  break; } } } else { _right--;//right를 한 칸 앞으로 옮기기  } } if (_left \u0026gt; _right)//left와 right가 역전되었을 경우  { break; } if (words[_left].Length \u0026gt; words[_right].Length)// left의 값이 right의 값보다 클 경우 서로 swap  { (words[_left], words[_right]) = (words[_right], words[_left]); } } (words[_pivot], words[_right]) = (words[_right], words[_pivot]);//역전된 right값과 pivot값을 swap  return _right;//right반환 =\u0026gt; 다음 pivot  } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, words)); }   최악의 경우 시간복잡도가 O(n^2)로 매우 성능이 떨어지게 된다. 아마 이걸 잡나보다\u0026hellip;. Quick Sort 말고 Merge Sort를 사용해 볼 걸 그랬다\u0026hellip;\n[문제풀러가기] (https://www.acmicpc.net/problem/1181)\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm8/","summary":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.","title":"AlgorithmStudy_백준 1181"},{"content":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm7 { class Beakjun1929 { static void Main(string[] args) { var list = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int m = list[0]; int n = list[1]; List\u0026lt;int\u0026gt; result = new List\u0026lt;int\u0026gt;(); //소수의 정의 : 1과 자기자신으로 밖에 나눌 없는 것..  for (int i = m; i \u0026lt;= n; i++) { if (i == 1) { continue; } if (i is \u0026gt; 1 and \u0026lt; 4)//2, 3은 소수  { result.Add(i); continue; } if (i % 2 == 0)//2의 배수는 모두 합성수  { continue; } bool primeNum = true; for (int k = 1; (k * 2 + 1) \u0026lt;= Math.Sqrt(i); k++)//소수는 다 홀수이다. =\u0026gt; 2k + 1  { //합성수라면 수의 제곱근보다 작거나 같은 수가 존재한다.  if (i % (k * 2 + 1) == 0) { primeNum = false;//소수가 아니다!  break; } } if (primeNum == true) { result.Add(i); } } StringBuilder sb = new StringBuilder(String.Join(\u0026#34;\\n\u0026#34;, result.ToArray())); Console.WriteLine(sb); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm7/","summary":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.","title":"AlgorithmStudy_백준 1929"},{"content":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)\n👉출력 예제와 같이 요세푸스 순열을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; var index = k - 1; Queue result = new Queue(); int[] people = new int[n]; for (int i = 0; i \u0026lt; n; i++) { people[i] = i + 1; } //배열로 하는 풀이  while (result.Count != n)//결과의 갯수가 n 값이 아닌동안  { if (people[index] \u0026gt; 0)//값이 0보다 크면  { result.Enqueue(people[index]);//결과에 enqeue  people[index] = 0;//결과에 넣은 값은 0으로  } if (result.Count == n) { break; } for (int i = 0; i \u0026lt; k; i++)//k번동안 인덱스 변경  { index = (index + 1) % n;//n의 크기를 넘지 않도록 설계  while(people[index] == 0)//값이 0인 경우 횟수로 치지 않음  { index = (index + 1) % n; } } } StringBuilder st = new StringBuilder(); st.Append(\u0026#34;\u0026lt;\u0026#34;); st.Append(string.Join(\u0026#34;, \u0026#34;, result.ToArray())); st.Append(\u0026#34;\u0026gt;\u0026#34;); Console.WriteLine(st); } } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  using System; using System.Collections; using System.Linq; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; Queue result = new Queue(); Queue que = new Queue(); for (int i = 1; i \u0026lt;= n; i++) { que.Enqueue(i); } //queue를 이용한 풀이  while (result.Count != n) { for (int i = 0; i \u0026lt; k - 1; i++)//k-1번째까지는 dequeue 후 다시 enqueue  { var pop =que.Dequeue(); que.Enqueue(pop); } result.Enqueue(que.Dequeue());//k번째에 결과값에 추가  } var r = string.Join(\u0026#34;, \u0026#34;, result.ToArray()); Console.WriteLine($\u0026#34;\u0026lt;{r}\u0026gt;\u0026#34;); } } }   🤣🤣 배열로 푼다고 고집부렸다가 애먹음..\n큐로 푸는 것이 정신건강에 좋은 것 같다.\n문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm6/","summary":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 11866"},{"content":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.\n👉출력 M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  using System; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var count_n = int.Parse(Console.ReadLine()!); var n = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var count_m = int.Parse(Console.ReadLine()!); var m = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var result = new int[m.Length]; Array.Sort(n); for (int i = 0; i \u0026lt; count_m; i++) { if (m[i] \u0026lt; n[0] || m[i] \u0026gt; n[^1]) //값이 범위에서 벗어나면 0  { result[i] = 0; continue; } int pivot = count_n / 2; //이진탐색을 활용!  int left = 0; int right = count_n - 1; while (true) { if (left \u0026gt; right) { result[i] = 0; break; } else { if (m[i] == n[pivot]) // 피봇과 값이 같은 경우  { result[i] = 1; break; } else if (m[i] \u0026gt; n[pivot]) // 피봇의 값보다 큰 경우  { left = pivot + 1; } else // 피봇의 값보다 작은 경우  { right = pivot - 1; } pivot = (left + right) / 2; } } } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   시간초과로 애먹었음\u0026hellip;\n출력 방식을 바꾸었더니 해결이 되었다..! (원래는 result를 돌면서 하나씩 출력했었다)\n문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm5/","summary":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.","title":"AlgorithmStudy_백준 1920"},{"content":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다. 조합한 것을 string으로 반환이 가능하다. 길이가 충분히 길고 길이를 모를 때 사용하는 것이 바람직하다.  1 2 3 4 5 6  StringBuilder sb1 = new StringBuilder(\u0026#34;Hello\u0026#34;); //생성할 당시에 바로 넣기가 가능하다. StringBuilder sb2 = new StringBuilder(100); //버퍼공간을 미리 할당하는 것이 가능하다. //미리 할당을 해놓으면 크기가 넘어가는 데이터가 들어오기 전까지는 Append를 사용할 시 추가 공간을 마련하지않아도 되어 조금 더 빠르다.    🌟🌟 StringBuilder가 편리함에도 string이 필요한 이유  값의 변형없이 사용되는 string 에 대한 참조만이 필요할 경우.  1 2 3 4 5 6 7 8  string a = \u0026#34;immutable\u0026#34;; //s1, s2, s3는 내부적으로 버퍼를 가지고 있지않기 때문에 a와 같은 버퍼를 참조한다. //만약, string이 StringBuilder처럼 작동을 한다면... //s1, s2, s3는 내부적으로 버퍼를 가지고 있어야하고 이는 a의 내부 버퍼를 복사한 값을 가지고 있을 것이다. =\u0026gt; 메모리 낭비! string s1 = a; string s2 = b; string s3 = c;    멀티스레드 환경에서 string이 StringBuilder보다 안전하다.  1 2 3 4 5 6 7 8  string s = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; //string을 조합할 때는 연산의 최소 단위인 원자적 연산을 하기 때문에 스레드가 연산 중간에 간섭할 수 없어 값이 변할 위험이 없다.  StringBuilder sb = new StringBuilder(); sb.Append(\u0026#34;a\u0026#34;); sb.Append(\u0026#34;b\u0026#34;); sb.Append(\u0026#34;c\u0026#34;); //StringBuilder로 조합할 경우에는 원자적 연산이 아니기 때문에 멀티스레드 환경에서 값이 변형될 위험이 있다.   ","permalink":"https://qutrits.github.io/en/posts/dummy/csharp1/","summary":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다.","title":"c#_string_StringBuilder"},{"content":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다. 하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.  문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.\n👉입력 첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.\n👉출력 첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tvar list = Console.ReadLine(); int count_zero = 0;//0이 쓰여진 카드 그룹의 갯수 (1 이 나오기 전까지의 카드 그룹) \tint count_one = 0;//1 이 쓰여진 카드 그룹의 갯수 (0 이 나오기 전까지의 카드 그룹) \tfor(int i = 0; i \u0026lt; list.Length - 1; ++i) { if(list[i] != list[i + 1]) //다음 카드와 비교했을 때 서로 다른 카드일 경우 \t{\tif(list[i] == \u0026#39;0\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0)//맨 처음 분기점 일 경우 \t{ count_one++;//그룹이 하나 생성 \t} count_zero++;//그룹 생성 \t} else if(list[i] == \u0026#39;1\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0) { count_zero++; } count_one++; } } } var result = Math.Min(count_zero, count_one); //더 작은 값을 출력 \tConsole.WriteLine(result);\t}\t}   문제풀러가기\n이..친구는.. 네번이나 틀렸다눈\u0026hellip; ㅠㅠ\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm4/","summary":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.","title":"AlgorithmStudy_백준 1439"},{"content":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.\n👉출력 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price)//가변지출이 제품 가격과 같거나 크면 손익이 날 수 없다. \t{ Console.WriteLine(-1);//-1 출력 \treturn; } int count = 1; int cost = 0; while(true) //카운트를 1씩 올리면서 손익분기점을 찾는다 \t{ cost = fix + variable * count; //총 비용 = 고정지출 + 가변지출 * 제품 갯수 \tif(price * count - cost \u0026gt; 0 )//순 이익 = 제품 가격 * 제품 갯수 - 총 비용 \t{ break; } count++; } Console.WriteLine(count); } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price) { Console.WriteLine(-1); return; } int count = 1; // 0이 되는 지점 =\u0026gt; fix + variable * count = price * count  // fix = (price - variable) * count \tcount = fix/(price - variable) + 1; Console.WriteLine(count); } }   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm3/","summary":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.","title":"AlgorithmStudy_백준 1712"},{"content":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","permalink":"https://qutrits.github.io/en/posts/dummy/my-first-post/","summary":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","title":"My First Post"},{"content":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.\n줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.\n줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 👉입력 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)\n👉출력 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  using System; using System.Linq; public class Program { public static void Main() {\tint people; people = int.Parse(Console.ReadLine()); //시간이 가장 적은 사람이 순으로 줄을 서면 전체가 돈을 인출하는 시간의 총합이 줄어들음 \tvar list = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select((int.Parse)).ToArray();\tArray.Sort(list);//정렬 \tvar result = list[0]; for(int i = 1; i \u0026lt; list.Length; ++i) { list[i] = list[i-1] + list[i]; result += list[i];//걸리는 시간 더하기 \t} Console.WriteLine(result); }\t}   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm2/","summary":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.","title":"AlgorithmStudy_백준 11399"},{"content":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.Parse(Console.ReadLine()); //입력받아 int로 전환 \tstring nums = Console.ReadLine(); //공백없이 숫자 입력 \tint result = 0; foreach(var item in nums)//item : char \t{ //변환된 값을 더하기. \tresult += int.Parse(item.ToString());//char-\u0026gt;string-\u0026gt;int \t} Console.WriteLine(result);\t}\t}   문제풀러가기\n","permalink":"https://qutrits.github.io/en/posts/dummy/algorithm1/","summary":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.","title":"AlgorithmStudy_백준 11720"},{"content":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.\n1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance); public \u0026lt;T\u0026gt; getFavorite(Class\u0026lt;T\u0026gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.\n1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.putFavorite(String.class, \u0026#34;JAVA\u0026#34;); f.putFavorite(Integer.class, 0xcafebabe); f.putFavorite(Class.class, Favorite.class); String favoriteString = f.getFavorite(String.class); Integer favoriteInteger = f.getFavorite(Integer.class); Class\u0026lt;?\u0026gt; favoriteClass = f.getFavorite(Class.class);   favorite 인스턴스는 type safe합니다. String을 요청했는데 Integer를 반환할 일이 없습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 타입 안전 이종 컨태이너 패턴 - 구현 public class Favorites { private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; favorite = new HashMap\u0026lt;\u0026gt;(); public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorite.put(Objects.requireNonNull(type), instance); } public \u0026lt;T\u0026gt; T getFavorite(Class\u0026lt;T\u0026gt; type) { return type.cast(favorites.get(type)); } }   Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt;에서 비한정적 와일드카드 타입을 사용해서 값을 아무것도 넣을 수 없을 거라고 생각할 수 있지만, 맵이 아니라 키가 와일드카드 타입이라서 값을 넣을 수 있습니다.\n지금 만든 Favorites 클래스에 주의점이 두 가지가 있습니다.\n첫 번째는 Class 객체를 raw type으로 넘기면 Favorites 인스턴스의 타입 안전성이 쉽게 깨집니다. Favorites가 타입 불변식이 어기는 일이 없도록 보장하려면 다음과 같이 수정할 수 있습니다.\n1 2 3  public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorites.put(Objects.requireNonNull(type, type.cast(instance))); }   java.util.Collections에는 checkedSet, checkedList, checkedMap 가 대표적으로 이 방식을 적용한 메서드입니다.\n두 번째는 실체화 불가 타입에는 사용할 수 없다는 것입니다. String이나 String[]는 저장할 수 있어도 List\u0026lt;String\u0026gt;은 저장할 수 없습니다. List\u0026lt;String\u0026gt;이나 List\u0026lt;Integer\u0026gt;는 List.class라는 같은 Class 객체를 공유하기 때문입니다.\n정리  컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있습니다. 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있습니다. 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 합니다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item33/","summary":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.\n1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance); public \u0026lt;T\u0026gt; getFavorite(Class\u0026lt;T\u0026gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.\n1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.","title":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라"},{"content":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.\n가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.\n실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다. 그리고 거의 모든 제네릭과 매개변수화 타입은 실체화되지 않습니다. 메서드 선언할 때 실체화 불가 타입으로 varargs 매겨변수를 선언하면 컴파일러가 경고를 보냅니다. 가변인수 메서드를 호출할 때도 varags 매개변수가 실체화 불가 타입으로 추론되면, 그 호출에 대해서도 경고를 냅니다.\n매개변수화 타입의 변수가 타입이 다른 다른 객체를 참조하면 힙 오염이 발생합니다. 이렇게 다른 타입 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있으니, 제네릭 타입 시스템이 약속한 타입 안전성의 근간이 흔들려버립니다. 다음 메서드를 예로 생각해봅시다.\n1 2 3 4 5 6  static void dangerous(List\u0026lt;String\u0026gt;... stringList) { List\u0026lt;Integer\u0026gt; integerList = Collections.singletonList(42); Object[] objects = stringList; objects[0] = integerList; // 힙 오염  String s = stringList[0].get(0); // ClassCaseException  }   가변인수와 제네릭을 사용하는 메서드는 대표적으로 Arrys.asList, Collections.addAll등이 있습니다. JAVA 7부터는 @SafeVarargs 에너테이션을 사용해서 그 메서드가 타입 안전성을 보장한다는 걸 알려줄 수 있습니다.\n메서드가 이 배열에 아무것도 저장하지 않는다면 괜찮지만 아무것도 저장하지 않고도 타입 안전성을 깨뜨릴 수 있습니다.\n1 2 3  static \u0026lt;T\u0026gt; T[] toArrays(T... args) { return args; }   이 메서드가 반환하는 타입은 이 메서드에 인수를 넘기는 컴파일타임에 결정되는데, 그 시점에는 컴파일러에게 충분한 정보가 주이지지 않아 타입을 잘못 판단할 수 있습니다. 따라서 varargs 매개변수 배열을 그대로 반환하면 힙 오염을 이 메서드를 호출한 쪽의 콕스 택으로 까지 전이할 수도 있습니다.\n1 2 3 4 5 6 7 8  static \u0026lt;T\u0026gt; T[] pickTwo(T a, T b, T c) { switch (ThreadLocalRandom.current().nextInt(3)) { case 0: return toArrays(a, b); case 1: return toArrays(a, c); case 2: return toArrays(c, b); } throw new AssertionError(); }   toArray 메서드가 돌려준 이 배열이 그대로 pickTwo를 호출한 클라이언트까지 전달되는데 항상 Object[] 타입 배열을 반환하게 됩니다.\n1  String[] attributes = pickTwo(\u0026#34;좋은\u0026#34;, \u0026#34;빠른\u0026#34;, \u0026#34;저렴한\u0026#34;);   런타임시 ClassCastException을 던집니다. pickTwo에서 Object[]을 반환하는데 String[]으로 변환하려고 해서 예외가 발생합니다.\n배열 내용의 일부 함수를 호출하는(varargs를 받지 않는)일반 메서드에 넘기는 것은 안전합니다.\n1 2 3 4 5 6 7 8  @SafeVarargs static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;? extends T\u0026gt;... lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;? extends T\u0026gt; list : lists) { result.addAll(list); } return result; }   임의 개수의 리스트를 받아서, 순서대로 그 안의 모든 원소를 하나의 리스트로 옮겨 반환하는 메서드입니다. @SafeVarargs 애너테이션은 안전하지 않은 varargs 메서드에는 절대 작성해서는 안 됩니다. 힙 오염 경고가 뜨면 무조건 검증을 해야합니다. 그리고 재정의할 수 없는 메서드에만 달아야 합니다. 재정의한 메서드도 안전할지는 보장할 수 없기 때문입니다.\n1 2 3 4 5 6 7  static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;List\u0026lt;? extends T\u0026gt;\u0026gt; lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;? extends T\u0026gt; list : lists) { result.addAll(list); } return result; }   위와 같이 @SafeVarargs 애너테이션을 사용하지 않고 verargs 매개변수를 List 매개변수로 바꿀 수도 있습니다.\n정리  가변인수와 제네릭은 궁합이 좋지 않습니다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이서 서로 다르기 때문입니다. 제네릭 verargs 매개변수는 type safe하지 않지만, 허용됩니다. verargs 매개변수를 사용하려면 타입이 안전한지 확인하고 @SafeVarargs 애너테이션을 이용합시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item32/","summary":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.\n가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.\n실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다.","title":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라"},{"content":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.\n아이템29의 Stack 클래스를 떠올려보면\n1 2 3 4 5 6  public class Stack\u0026lt;T\u0026gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;E\u0026gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다. 하지만 Stack\u0026lt;Number\u0026gt;로 선언한 후 pushAll(intVal)을(Iteger 타입) 호출하면 오류가 뜹니다. 매개변수 타입이 불공변이기 떄문입니다.\n이러한 상황에서는 한정된 와일드카드(unbounded wildcard)를 이용해서 해결할 수 있습니다. pushAll의 입력 매개변수 타입은 \u0026lsquo;E의 iterable\u0026lsquo;이 아니라 \u0026lsquo;E의 하위타입 Iterable\u0026lsquo;이어야 하며, 와일드 카드 Iterable\u0026lt;? extends E\u0026gt;가 정확히 이런뜻입니다.\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;? extends E\u0026gt; src) { for (E e : src) { push(e); } }   위와 같이 수정할 수 있습니다. 이번에는 popAll메서드를 와일드카드 타입을 사용하지 않고 작성해 보겠습니다.\n1 2 3 4 5 6  // 와일드카드 타입을 사용하지 않은 메서드 - 결함이 있습니다. public void popAll(Collection\u0026lt;E\u0026gt; dst) { while (!isEmpty()) { dst.add(pop()); } }   1 2 3  Stack\u0026lt;Number\u0026gt; numberStack = new Stack\u0026lt;\u0026gt;(); Collection\u0026lt;Object\u0026gt; objects = ...; numberStack.popAll(objects);   컴파일 하면 \u0026ldquo;Collection\u0026lt;Object\u0026gt;는 Collection\u0026lt;Nummber\u0026gt;의 하위 타입이 아니다\u0026rdquo; 라는 오류가 발생합니다. 이번에는 반대로 \u0026lsquo;E의 Collection\u0026rsquo; 이 아니라 \u0026lsquo;E의 상위타입 Collection\u0026rsquo; 이어야 합니다.\n1 2 3 4 5 6  // 와을드카드 타입을 사용하지 않은 메서드 - 결함이 있습니다. public void popAll(Collection\u0026lt;E super E\u0026gt; dst) { while (!isEmpty()) { dst.add(pop()); } }   위와 같이 수정할 수 있습니다. 메세지는 분명합니다. 유연성을 극대화하려면 원소의 생산자나 소비자용 매개변수에 와일드 카드를 사용합시다. 한편,입력 매개변수가 생상자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없습니다. 타입을 정확히 지정해야 하는 상황으로, 이때는 와일드카드 타입을 쓰지말아야합니다.\n다음 공식을 외워두면 어떤 와일드 카드 타입을 써야 하는지 도움이 될 것입니다.\n PECS: producer-extends, consumer-super\n 즉 매개변수화 타입 T가 생성자라면 \u0026lt;? extends T\u0026gt;를 사용하고, 소비자라면 \u0026lt;?super T\u0026gt;를 사용합시다.\n클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 큽니다.\n1 2  // 아이템30 에서 사용했던 코드 public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(List\u0026lt;E\u0026gt; c);   아이템30\n위 코드를 와일드카드 타입을 사용해 다듬은 모습입니다.\n1 2  // 아이템30 에서 사용했던 코드 public static \u0026lt;E extends Comparable\u0026lt;? super E\u0026gt;\u0026gt; E max(List\u0026lt;? extends E\u0026gt; c);   위 코드는 PECS 공식을 두 번 적용했습니다. 입력 매개변수에서는 E 인스턴스를 생산하므로 원래의 List\u0026lt;E\u0026gt;를 List\u0026lt;? extends E\u0026gt;로 수정했습니다.\n원래 선언에서는 E가 Comparale\u0026lt;E\u0026gt;를 확장한다고 정의했는데, 이때 Comparable\u0026lt;E\u0026gt;는 E인스턴스를 소비합니다. (그리고 선후 관계를 뜻하는 정수를 생산합니다) 그래서 매개변수화 타입 Comparable\u0026lt;E\u0026gt;는 E 한정적 와일드카드 타입 Comparable\u0026lt;? super E\u0026gt;로 대체 했습니다.\nComparable은 언제나 소비자이므로, 일반적으로 Comparable, Comparable\u0026lt;E\u0026gt;보다는 Comparable\u0026lt;? super E\u0026gt;를 사용하는 편이 낫습니다.\nComparator도 마찬가지입니다. 일반적으로 Comparator\u0026lt;E\u0026gt;보다는 Comparator\u0026lt;? super E\u0026gt;를 사용하는 편이 낫습니다.\n와일드카드와 관련해 논의해야 할 주제가 더 있습니다. 타입 매개변수와 와일드카드에 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느것을 사용해도 괜찮을 때가 많습니다.\n1 2  public static \u0026lt;E\u0026gt; void swap(List\u0026lt;E\u0026gt; list, int i, int j); public static swap(List\u0026lt;?\u0026gt; list, int i, int j);   public API라면 간단한 두 번째가 낫습니다. 어떤 리스트든 이 메서드에 넘기면 명시한 인덱스의 원소들을 교환해 줄 것입니다. 신경 써야 할 타입 매개변수도 없습니다.\n기본 규칙은 이렇습니다. 메서드에 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라. 이때 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 됩니다.\n하지만 두 번째 swap 선언에는 문제가 하나 있는데, 다음과 같이 직관적으로 구현한 코드가 컴파일 되지 않는다는 것입니다.\n1 2 3 4  public static swap(List\u0026lt;?\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } // 방금 꺼낸 원소를 리스트에 다시 넣을 수 없습니다.   원인 리스트의 타입이 List\u0026lt;?\u0026gt;인데, List\u0026lt;?\u0026gt;에는 null 외에는 어떤 값도 넣을 수 없기 때문입니다.\n1 2 3 4 5 6 7 8  public static swap(List\u0026lt;?\u0026gt; list, int i, int j) { swapHelper(list, i, j); } // 와일드카드 타입을 실제 타입으로 바꿔주는 private 도우미 메서드 public static \u0026lt;E\u0026gt; void swapHelper(List\u0026lt;E\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); }   swapHelper 메서드는 리스트가 List\u0026lt;E\u0026gt;임을 알고 있습니다. 즉, 이 리스트에서 꺼낸 값은 항상 E이고, E 타입의 값이라면 이 리스트에 넣어도 안전함을 알고 있습니다.\n다소 복잡하지만 덕분에 외부에서는 와일드카드 기반의 멋진 선언을 유지할 수 있습니다. 즉 swap 메서드를 호출 하는 클라이언트는 복잡힌 swapHelper의 존재를 모른 채 그 혜택을 누리는 것입니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item31/","summary":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.\n아이템29의 Stack 클래스를 떠올려보면\n1 2 3 4 5 6  public class Stack\u0026lt;T\u0026gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;E\u0026gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다.","title":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라"},{"content":"[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.\n1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다. 다음 코드에서 타입 매개변수 목록은 \u0026lt;E\u0026gt;이고 반환 타입은 Set\u0026lt;E\u0026gt;입니다.\n1 2 3 4 5  public static \u0026lt;E\u0026gt; Set\u0026lt;E\u0026gt; union(Set\u0026lt;E\u0026gt; s1, Set\u0026lt;E\u0026gt; s2) { Set\u0026lt;E\u0026gt; result = new HashSet\u0026lt;\u0026gt;(s1); result.addAll(s2); return result; }   다음 코드는 이 메서드를 사용하는 프로그램입니다. 직접 형변환 하지 않아도 어떤 오류나 경고 없이 컴파일 됩니다.\n1 2 3 4 5 6  public static void main(Sting[] args) { Set\u0026lt;String\u0026gt; guys = Set.of(\u0026#34;pual\u0026#34;, \u0026#34;jin\u0026#34;); Set\u0026lt;String\u0026gt; stooges = Set.of(\u0026#34;jerry\u0026#34;, \u0026#34;sia\u0026#34;); Set\u0026lt;String\u0026gt; aflCio = union(guys, stooges); System.out.println(aflCio); }   이를 한정적 와일드카드 타입을 사용하면 더 유연하게 개선할 수 있습니다.\n제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입으로든 매개변수화 할 수가 있습니다. 하지만 이렇게 하려면 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 합니다. 이 패턴을 제네릭 싱글턴 팩터티라 하며, Collections.reverseOrder 같은 함수 객체나 Collections.emptySet 같은 컬렉션용으로 사용합니다.\n이번에는 항등함수를 담은 클래스를 만들고 싶다고 해봅시다. 자바 라이브러리의 Function.idenify를 사용해도 되지만 직접 작성해 보겠습니다. 항등함수 객체는 상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비입니다. 자바의 제네릭이 실체화된다면 항등함수를 타입별로 하나씩 만들어야 했겠지만, 소거 방식을 사용한 덕에 제네릭 싱글턴 하나면 충분합니다.\n1 2 3 4 5 6  private static UnaryOperator\u0026lt;Object\u0026gt; IDENTIFY_FN = (t) -\u0026gt; t; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; UnaryOperator\u0026lt;T\u0026gt; identifyFunction() { return (UnaryOperator\u0026lt;T\u0026gt;) IDENTIFY_FN; }   T가 어떤 타입이든 UnaryOperator\u0026lt;T\u0026gt;를 사용해도 type safe합니다.\n상대적으로 드물긴 하지만 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있습니다. 바로 재귀적 타입 한정이라는 개념입니다. 주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰입니다.\n1 2 3  public interface Comparable\u0026lt;T\u0026gt; { int compareTo(T o); }   타입 매개변수 T는 Comparable\u0026lt;T\u0026gt;를 구현한 타입이 비교할 수 있는 원소의 타입을 정의합니다. 실제로 거의 모든 타입은 자신과 같은 타입의 원소와만 비교할 수 있습니다. 따라서 String은 Comparable\u0026lt;String\u0026gt;을 구현하고 Integer는 Comparable\u0026lt;Integer\u0026gt;를 구현한 식입니다.\n1  public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c);   타입 한정인 \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt;는 \u0026ldquo;모든 타입 E는 자신과 비교할 수 있다\u0026quot;라고 해석할 수 있습니다.\n다음은 방금 선언한 메서드의 구현입니다. 컬렉션에 담긴 원소의 자연적 순서를 기준으로 최댓값을 계산하며, 컴파일 오류나 경고는 발생하지 않습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c) { if (c.isEmpty()) { throw new IllegalArgumentException(\u0026#34;컬렉션이 비어 있습니다.\u0026#34;); } E result = null; for (E e : c) { if (result == null || e.compareTo(result) \u0026gt; 0) { result = Objects.requireNonNull(e); } } return result; }   정리  제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽습니다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item30/","summary":"[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.\n1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다.","title":"[아이템 30] 이왕이면 제네릭 메서드로 만들라"},{"content":"[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } ... 중략 }   컴파일러는 이 프로그램이 안전한지 증명할 방법은 없지만, 우리는 할 수 있는 한 이 비검사 형변환이 프로그램의 타입 안전성을 해치지 않는지 스스로 확인해야합니다.\n비검사 형변환이 안전하다는 걸 확인했다면 범위를 최소로 좁혀 @SuppressWarnings(\u0026quot;unchecked\u0026quot;)를 이용하여 해당 경고를 숨깁시다.\n1 2 3 4 5 6 7  // 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다. // 따라서 타입 안전성을 보장하지만 // 이 배열의 런타임 타입은 E[]가 아닌 Object[]입니다. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; }   위 방법 말고 다른 방식으로는 elements 필드의 타입을 E[]에서 Object[]로 바꾸는 것입니다. 이렇게 하면 pop메서드 부분을 다음과 같이 수정해줘야 합니다.\n1  E result = (E) elements[--size];   E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없습니다. 이번에도 직접 증명하고 경고를 숨길 수 있습니다.\n1 2  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E result = (E) elements[--size];   첫 번째 방식은 형변환을 배열 생성시 단 한 번만 해주면 되지만, 두 번째 방식에서는 배열에서 원소를 읽을 때마다 해줘야하므로 첫 번째 방식이 더 자주 사용됩니다. 하지만 (E가 Object가 아닌 한) 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염을 일으킵니다.\n사실 제네릭 타입 안에서 리스트를 사용하는 게 항상 가능하더라도, 꼭 더 좋은 건 아닙니다. 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 합니다. 또한 HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 합니다.\n정리  클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편합니다. 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 합시다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경합시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item29/","summary":"[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } .","title":"[아이템 29] 이왕이면 제네릭 타입으로 만들라"},{"content":"[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.\n반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List\u0026lt;Type1\u0026gt;은 List\u0026lt;Type2\u0026gt;의 하위 타입도 아니고 상위 타입도 아닙니다.\n이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.\n1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = \u0026#34;타입이 달라 넣을 수 없다.\u0026#34;; // 런타임시 ArrayStoreException을 던진다   1 2  // 컴파일 에러 List\u0026lt;Object\u0026gt; ol = new ArrayList\u0026lt;Long\u0026gt;(); // 호환되지 않는 타입   어느 쪽이든 Long용 저장소에 String을 넣을 수 없습니다. 다만 배열 같은 경우 런타임에야 알 수 있고, 리스트는 컴파일 시에 알아챌 수 있어서 더 좋습니다.\n두번째 차이점. 배열은 실체화(reify)됩니다. 무슨 뜻이냐면 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인합니다. 그래서 위 코드에서 Long배열에 String을 넣으려 하면 ArrayStoreException이 발생합니다. 반면 제네릭은 타입 정보가 런타임에는 소거(erasure)됩니다.\n원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수 조차도 없다는 뜻입니다. 소거는 제네릭 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘으로, JAVA 5가 제네릭으로 순조롭게 전환될 수 있도록 해주었습니다.\n이상의 주요 차이로 인해 배열과 제네릭은 잘 어울러지지 못합니다. 예컨대 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없습니다. 즉 코드를 new List\u0026lt;E\u0026gt;[], new List\u0026lt;String\u0026gt;[], new E[] 식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킵니다.\n제네릭 배열을 만들지 못하게 막은 이유 타입이 안전하지 않기 때문입니다. 이를 허용하면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCaseException이 발생할 수 있습니다. 런타임에 ClassCaseException이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것입니다.\n1 2 3 4 5 6  // 컴파일 되지 않는다. List\u0026lt;String\u0026gt;[] stingLists = new List\u0026lt;String\u0026gt;[1]; // (1) List\u0026lt;Integer\u0026gt; intList = List.of(42); // (2) Object[] objects = stingLists; // (3) Object[0] = intList; // (4) String s = stingLists[0].get(0); // (5)   제네릭 배열을 생성하는 (1)이 허용된다고 가정해봅시다. (2)는 원소 하나인 List\u0026lt;Integer\u0026gt;를 생성합니다. (3)은 (1)에서 생성한 List\u0026lt;String\u0026gt;의 배열을 Object 배열에 할당합니다.\n배열은 공변이니 아무 문제가 없습니다. (4)는 (2)에서 생성한 List\u0026lt;Integer\u0026gt;의 인스턴스를 Object 배열의 첫 원소로 저장합니다. 제네릭은 소거 방식으로 구현되어서 이 역시 성공합니다.\n즉, 런타임에는 List\u0026lt;Integer\u0026gt; 소거 방식으로 이 역시 소거됩니다. 즉 런타임에는 List\u0026lt;Integer\u0026gt;인스턴스의 타입은 단순히 List가 되고, List\u0026lt;Integer\u0026gt;[] 인스턴스의 타입은 List[]가 됩니다. 따라서 (4)에서도 ArrayStoreException을 발생시키지 않습니다.\n문제는 List\u0026lt;String\u0026gt;인스턴스만 담겠다고 선언한 stingLists 배열에는 지금 List\u0026lt;Inrteger\u0026gt; 인스턴스가 저장돼 있습니다. 결국 (5)에서 ClassCaseExceptionn이 발생하게 됩니다. 이런 일을 방지하려면 (제네릭 배열이 생성되지 않도록) (1)에서 컴파일 오류를 발생해야 합니다.\nE, List\u0026lt;E\u0026gt;, List\u0026lt;String\u0026gt; 같은 타입을 실체화 불가 타입(non-reifiable type)이라 합니다. 쉽게 말하자면, 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입입니다. 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 List\u0026lt;?\u0026gt;와 Map\u0026lt;?, ?\u0026gt;같은 비한정적 와일드카드 타입뿐입니다. 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 별로 없습니다.\n정리  배열은 공변이고 실체화가 되지만 제네릭은 불공변이고 타입 정보가 소거됩니다. 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않습니다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item28/","summary":"[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.\n반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List\u0026lt;Type1\u0026gt;은 List\u0026lt;Type2\u0026gt;의 하위 타입도 아니고 상위 타입도 아닙니다.\n이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.\n1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = \u0026#34;타입이 달라 넣을 수 없다.","title":"[아이템 28] 배열보다는 리스트를 사용하라"},{"content":"[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.\n제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.\n대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.\n(javac 명령줄 인수에 -Xlint:unchecked 옵션을 추가해야 합니다.)\n컴파일러가 알려준 대로 수정하면 경고가 사라집니다. JAVA 7부터는 컴파일러가 알려준 타입 매개변수로 명시하지 않아도 타입 추론을 지원합니다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset\u0026lt;\u0026gt;();   할 수 있는 한 모든 비검사 경고를 제거합시다. 모두 제거한다면 그 코드는 타입 안전성이 보장됩니다. 경고를 제거할 수는 없지만 타입이 안전하다고 확신이 들 때는 @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애너테이션을 달아 경고를 숨깁시다. @SuppressWarning 애너테이션은 개별 지역번수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있습니다. 하지만 가능한 좁은 범위에 적용하는 게 좋습니다.\n자칫 심각한 경고를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 됩니다. @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 합니다.\n정리  비검사 경고는 중요하니 무시하지 말자. 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성이 있습니다. 경고를 없앨 방법을 찾지 못했다면, 그 코드의 안전함을 증명하고 가능한 범위를 좁혀서 @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애노테이션으로 경고를 숨깁시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item27/","summary":"[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.\n제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.\n대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.","title":"[아이템 27] 비검사 경고를 제거하라"},{"content":"[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.\n1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.\n1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다. (경고 메세지를 보여주긴 합니다.)\n1 2 3  naems.add(1); // \u0026#34;Unchecked call\u0026#34; 경고를 보여줍니다.  String str = (String) names.get(0); // ClassCastException   컴파일 오류를 체크하지 못하고 런타임할 때 예외가 발생하게 됩니다. 가장 이상적인 오류는 컴파일할 때 발견하는 것이 좋습니다. 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커집니다.\n제네릭을 활용하면 이 정보가 주석이 아닌 타입 선언 자체에 녹아듭니다.\n1 2  // 매개변수화된 컬렉션 타입 - 타입 안전성 확보 private final List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;();   이렇게 선언하면 컴파일러는 names에는 String만 넣어야 함을 컴파일러가 인지하게 됩니다. 이제 names에 엉뚱한 타입의 인스턴스를 넣으려고하면 컴파일 오류가 발생합니다.\n1  names.add(1); // 컴파일 오류   앞에서도 얘기했듯, raw type(타입 매개변수가 없는 제네릭 타입)은 절대로 사용해서는 안 됩니다.\nraw type을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 됩니다. raw type을 만들어놓은 이유는 호환성 때문입니다. 자바가 제네릭을 받아들이기까지 거의 10년이 걸린 탓에 제네릭 없이 짠 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했습니다.\nList vs List\u0026lt;Objects\u0026gt; raw typeList는 제네릭 타입에서 완전히 발을 뺀 것이고, List\u0026lt;Object\u0026gt;는 모든 타입을 허용한다는 의사를 컴파일러에게 전달한 것입니다. 매개변수로 List를 받는 메서드에 List\u0026lt;String\u0026gt;를 넘길 수 있지만, List\u0026lt;Object\u0026gt;를 받는 메서드에는 List\u0026lt;String\u0026gt;를 넘길 수 없습니다. 이는 제네릭의 하위 타입 규칙 때문입니다.\n즉, List\u0026lt;Integer\u0026gt;는 raw type인 List의 하위타입 이지만, List\u0026lt;Object\u0026gt;의 하위타입은 아닙니다. 그 결과 List\u0026lt;Object\u0026gt;같은 매개변수화 타입을 사용할 때와 달리 List같은 raw type을 사용하면 타입 안전성을 잃게 됩니다.\n예제를 위한 코드 1 2 3  // Interger는 Number의 서브 타입입니다. List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Number\u0026gt; numberList = intList; // 컴파일 에러   1 2  List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); List rawType = intList; // 오류가 발생하지 않지만, 안전하지 않습니다.   이쯤 되면 원소의 타입을 몰라도 되는 raw type을 쓰고 싶어질 수 있습니다. 그럴 땐 비한정적 와일드 타입(unbounded wildcard types)를 사용하는 대안이 있습니다. 이는 타입 파리머티에 ?을 작성하면 됩니다.\n1 2  // unbounded wildcard type - 타입 세이프하고 유연합니다, static int numElementsInCommon(Set\u0026lt;?\u0026gt; s1, Set\u0026lt;?\u0026gt; s2) { ... }   그렇다면 비한정적 와일드카드 타입인 Set\u0026lt;?\u0026gt;와 raw type인 Set의 차이는 무엇일까? 물음표가 무언가 멋진 일은 해주는 것일까?\n와일드 카드는 type safe하고 raw type은 그렇지 않다는 점입니다. raw type원소에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽습니다.\n반면 Collection\u0026lt;?\u0026gt;에는 (null 이외는) 어떤 원소도 넣을 수 없습니다. 다른 원소를 넣으려 하면 컴파일 할 때 오류 메세지를 보여줍니다. 이러한 제약을 받아들일 수 없다면 제네릭 메서드나 bounded wildcard type을 사용하면 됩니다.\nraw type을 사용하지 말라는 규칙에도 소소한 예외가 몇 개 있습니다. class 리터럴에는 raw type을 사용해야 합니다. 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했습니다. (배열과 기본 타입은 허용합니다.)\n예를 들어 List.class.String[].class, int.class는 허용하고 List\u0026lt;String\u0026gt;.class와 List\u0026lt;?\u0026gt;.class는 허용하지 않습니다.\n두 번째 예외는 instance of 연산자와 관련이 있습니다. 런타임에는 제네릭 타입 정보가 지워지므로 instance of 정보가 지워지므로 instance of 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없습니다.\n정리  raw type을 사용하면 런타임 예외가 일어날 수 있으니 사용하면 안 됩니다. raw type은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐입니다. Set\u0026lt;Object\u0026gt;는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입입니다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-04/item26/","summary":"[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.\n1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.\n1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다.","title":"[아이템 26] Raw 타입은 사용하지 마라"},{"content":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.\nUtensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; }   Main을 실행하면 \u0026ldquo;pancake\u0026quot;가 출력됩니다.\n이제 두 클래스를 담은 Dessert.java라는 파일을 만들었다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pot\u0026#34;; } class Dessert { static final String NAME = \u0026#34;pie\u0026#34;; }   컴파일러는 가장 먼저 Main.java를 컴파일하고, 그 안에서 (Dessert 참조보다 먼저 나오는) Utensil 참조를 만나면 Utensil.java 파일을 살펴 Utensil과 Dessert를 모두 찾아낼 것입니다. 그런 다음 컴파일러가 두 번째 명령줄 인수로 넘어온 Dessert.java를 처리하려 할 때 같은 클래스의 정의가 이미 있음을 알게 됩니다.\n한편 javac Main.java나 javac Main.java Utensil.java명령으로 컴파일하면 Dessert.java파일을 작성하기 전처럼 \u0026ldquo;pancake\u0026quot;를 출력합니다. 그러나 javac Dessert.java Main.java명령으로 컴파일하면 \u0026ldquo;potpie\u0026quot;를 출력합니다. 이처럼 컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라지므로 반로 잡아야할 문제입니다. 다행히 해결책은 간단합니다. 단순힌 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 그만입니다.\n굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 멤버 클래스를 사용하는 방법을 고민해볼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Test { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } private static class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } private static class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; } }   ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item25/","summary":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.\nUtensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; }   Main을 실행하면 \u0026ldquo;pancake\u0026quot;가 출력됩니다.","title":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라"},{"content":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.\n중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.\n 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.\n정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다. 정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰입니다.\n비정적 멤버 클래스 비정적 멤버 클래스의 인스턴스 바깥 클래스의 인스턴스와 암묵적으로 연결됩니다. 그래서 비정적 멤버 클래스의 인스턴스는 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있습니다.\n여기서 말하는 정규화된 this란 클래스명.this 형태로 바깥 클래스의 이름을 명시하는 용법을 말합니다. 따라서 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 합니다. 비정적 멤버 클래스는 바깥 인스턴스 없이 생성할 수 없기 때문입니다.\n바깥 클래스의 인스턴스 메서드에 비정적 멤버 클래스의 생성자를 호출할 때 자동으로 만들어지는 게 보통이지만, 드물게 직접 바깥 인스턴스의 클래스명.new MemberClass()를 호출해 수동으로 만들기도 하지만 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하며, 생성 시간도 더 걸립니다.\n비정적 멤버 클래스는 어댑터를 정의할 때 자주 사용됩니다. 즉 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용됩니다. 예컨대 Map 인터페이스의 구현체들은 보통 (keySet, entrySet메서드가 반환하는) 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스를 사용합니다.\n멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만듭시다. static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 됩니다. 이렇게 되면 시간과 공긴이 소비되고 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있습니다.\n익명 클래스 익명 클래스는 바깥 클래스의 멤버가 아닙니다. 멤법와 달리, 쓰이는 시점에 선언과 동시에 인스턴스로 만들어집니다. 그리고 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있으며 instance of검사나 클래스의 이름이 필요한 작업은 수행할 수 없습니다.\n자바가 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체(process object)를 만드는 데 만드는 데 익명 클래스를 주로 사용했으며 또 정적 팩터리 메서드를 구현할 때입니다.\n지역 클래스 지역 클래스는 네 가지 중첩 클래스 중 가장 드물게 사용됩니다. 지역 클래스는 지역 변수를 선언할 수 있는 곳이면 실직적으로 어디서든 선언할 수 있고, 유효범위도 지역변수와 같습니다.\n정리  중첩 클래스에는 네 가지가 있으며, 각각의 쓰임이 다릅니다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만듭니다. 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로. 그렇지 않으면 정적으로 만듭시다. 중첩 클래스가 한 메서드 안에서만 사용되며 그 인스턴스를 생선하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 있다면 익명 클래스로 만들고, 그렇지 않으면 지역 클래스로 만듭시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item24/","summary":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.\n중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.\n 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.\n정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다.","title":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라"},{"content":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.\n안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.  final Shape shape; // 모양이 사각형(RECTANGLE)일 때만 쓰입니다.  double length; double width; // 다음 필드 모양이 원(CIRCLE)일 때만 쓰입니다.  double radius; // 원 생성  Figure(double radius) { shape = Shape.CIRCLE; this.radius = radius; } Figure(double length, double width) { shape = Shape.RECTANGLE; this.length = length; this.width = width; } double area() { switch (shape) { case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(); } } }   태그 달린 클래스에는 단점이 많습니다. 열거 타입 선언, 태그 필드, switch문 등 잡다한 코드가 너무 많습니다. 여러 구현이 한 클래스에 있어서 구현도 나쁩니다. 인스턴스가 다른 특징에 속하는 관련없는 필드로 인해 메모리도 많이 사용하게 됩니다.\n또 다른 의미를 추가하려면 switch문을 찾아 새 의미를 처리하는 코드를 추가해야하는 데 하나라도 빠뜨리면 문제가 될 수도 있습니다. 마지막으로, 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 없습니다.\n태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적입니다.\n클래스 계층구조를 활용하는 서브타이핑을 이용해서 타입 하나로 다양한 의미의 객체를 표현할 수 있습니다. 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일뿐입니다.\n태그달린 클래스를 클래스 계층 구조로 바꾸는 방법  계층구조의 루트가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언합니다. 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래승 일반 메서드로 추가합니다. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올립니다. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의합니다.  Figure 클래스에서는 태그 값과 상관없는 메서드가 하나도 없고, 모든 하위 클래스에서 사용하는 공통 데이터 필드가 없습니다. 그 결과 루트 클래스에는 추상메서드 area하나만 남게 됩니다.\n다음은 Figure 클래스를 계층구조 방식으로 구현한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  abstract class Figure { abstract double area; } public class Circle extends Figure{ final double radius; public Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * (radius * radius); } } // Rentangle 클래스 위와 같은 방식으로 구현하면 됩니다.   태그 달린 클래스에 비교하면 쓸데 없는 코드들은 모두 제거했고, 각 의미를 독립된 클래스에 담아 관련 없던 데이터 필드를 모두 제거했습니다.\n살아 남은필드들은 모두 final이며 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고 추상 메서드를 구현했는지 컴파일러가 확인해줍니다.\n정리  태그 달린 클래스를 써야 하는 상황은 거의 없습니다. 새로운 클래스를 작성할 때 태그 필드가 등자했다면 계층 구조롤 대체하는 방법을 고려해보자. 기존 클래스가 필드를 사용하고 있다면 계층구조로 리팩터링 하는 걸 고려민해보자.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item23/","summary":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.\n안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.","title":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자"},{"content":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.\n이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.\n1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e34; static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; static final double ELECTRON_MASS = 9.109_383_56e-31; }   상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예입니다. 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당합니다. 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위입니다. 클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없습니다. 오히려 혼란을 줄 수가 있으며, 더 심각하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에게 종속되게 합니다.\n그래서 다음 릴리즈에서 이 상수들을 더는 쓰지 않게 되더라도 바이너리 호환성을 위해 여전히 상수 인터페이스를 구현하고 있어야 합니다. final이 아닌 클래스가 상수 인터페이스를 구현한다면 모든 하위 클래스의 네임스페이스가 그 인터페이스가 정의한 상수들로 오염되어 버립니다.\njava.io.ObjectStreamConstants 등, 자바 플랫폼 라이브러리에도 상수 인터페이스가 몇 개 있으나, 인터페이스를 잘못 활용한 예이니 따라 해서는 안 됩니다. 상수를 공개할 목적이라면 더 합당한 방법들이 있습니다.\n특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야합니다. 대표적으로 Integer와 Double에 선언된 MIN_VALUE와 MAX_VALUE 상수가 이런 예입니다. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들면 되고 그것도 아니라면 인스턴스화 할 수 없는 유틸클래스에 담아 공개하면 됩니다.\n1 2 3 4 5 6 7 8 9  // 유틸리티 클래스  public class PhysicalConstants { private PhysicalConstants() static final double AVOGADROS_NUMBER = 6.022_140_857e34; ... 생략 }   정리  인터페이스는 타입을 정의하는 용도로만 사용해야 합니다, 실수 공개용 수단으로 사용하지 맙시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item22/","summary":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.\n이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.\n1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.","title":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라"},{"content":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.\nJAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.\n즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.\n자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.\n1 2 3 4 5 6 7 8 9 10 11 12  default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; }   자바 8 Collection 인터페이스에 추가된 removeIf 메서드입니다.\n이코드보다 더 범용적으로 구현하기도 어렵겠지만, 그렇다고 해서 현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아닙니다.\n대표적인 예가 org.apache.commons.collections4.collection.SynchronizedCollection입니다. 이 클래스는 java.util.Collections.synchronizedCollction 정적 팩터리 메서드가 반환하는 클래스와 비슷합니다. 아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공합니다. 즉, 모든 메서드에 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스입니다.\n아파치의 SynchronizedCollection는 removieIf메서드를 재정의하고 있지 않습니다. 이 첵이 쓰여진 시점에는 removeIf를 재정의하고있지 않습니다. 이 클래스는 removeIf를 재정의 하고있지 않습니다. 그래서 이 클래스를 JAVA 8과 함께 사용하면 모든 메서드 호출을 알아서 동기화해주지 못합니다.\n자바 플랫폼 라이브러리에서도 이런 문제를 예방하기 위해 조치를 취했습니다. 예를 들어 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했습니다.\n핵심은 인터페이스를 설계할 때는 세심한 주의를 기울여야 합니다. 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 커다란 위험도 딸려옵니다. 새로운 인터페이스라면 릴리즈 전에 반드시 테스트를 거쳐야 합니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item21/","summary":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.\nJAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.\n즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.\n자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.","title":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라"},{"content":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.\n추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.\n반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있습니다. 그저 인터페이스가 요구하는 메서드를 (아직 없다면) 추가하고, 클래스 선언에 implements 구문을 추가하면 됩니다.\n반면 일반적으로 기존 클래스에 새로운 추상 클래스를 끼워넣는 일은 매우 간단합니다. 만약 두 클래스로 하나의 추상 클래스를 상속하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야합니다. 이러한 방식은 클래스 계층구조에 커다란 혼란을 야기할 수 있습니다. 적절하지 않은 상황에서도 강제로 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것입니다.\n인터페이스는 믹스인(mixin) 정의에 안성맞춤입니다. 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 \u0026lsquo;주된 타입\u0026rsquo;외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 줍니다.\n예컨대 Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스입니다. 이처럼 대상 타입의 주된 기능에 선택적 기능을 \u0026lsquo;혼합(mixed in)\u0026lsquo;한다고 해서 믹스인이라고 불립니다.\n반면 추상 클래스로는 믹스인을 정의할 수 없습니다. 기존 클래스에 덧씌울 수 없기 때문입니다. 클래스는 두 부모를 섬길 수 없고, 클래스 계층구조에는 믹스인을 삽입하기엔 합리적인 위치가 없기 때문입니다.\n인터페이스는 계층구조가 없는 타입 프레임워크 만들 수 있습니다. 1 2 3 4 5 6  public interface Singer { AudioClip sing(Song s); } public interface Songwriter { Song compose(int chartPosition); }   현실에는 계층을 엄격히 구분하기 어려운 개념이 있습니다. 위 코드처럼 타입을 인터페이스로 정의하면 가수 클래스가 Singer와 SongWriter 모두를 구현해도 전혀 문제가 되지 않습니다.\n1 2 3  public interface SingerSongWriter extends Singer, Songwriter { AudioClip strum(); }   이런식으로 Singer와 Songwriter모두를 확장하고 새로운 메서드까지 추가한 제3의 인터페이스도 정의할 수 있습니다. 같은 구조를 클래스로 만드려면 속성이 n개라면 지원해야 할 조합의 수는 2^n개가 됩니다 이러한 현상을 조합 폭발(combinatorial explosion)이라고 부릅니다.\n인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공하는 것도 방법입니다. 하지만 디폴트 메서드에도 제약이 있습니다. 많은 인터페이스가 equals와 hashCode같은 Object의 메서드를 정의하고 있지만, 이들은 디폴트 메서드로는 제공해서는 안 됩니다.\n또한 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적멤버도 가질 수 없습니다. 마지막으로 여러분들이 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없습니다.\n정리   일반적으로 다중 구현용 타입으로는 인터페이스가 적합합니다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법도 고려하는걸 추천합니다.   ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item20/","summary":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.\n추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.\n반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다.","title":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라"},{"content":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.\n상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.  상속을 허용하는 클래스가 지켜야 할 제약 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됩니다.\n상위 클래스의생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됩니다.\n상속을 금지하는 방법에는 두 가지 방법이 있습니다. 첫 번째는 클래스를 final으로 선언하는 것과 두번째는 모든 생성자를 private나 package-private로 선언하고 public 정적 팩터리를 만들어주는 방법입니다.\n정리  상속을 하려면 문서화를 해야 하며, 문서화 한 것은 반드시 지켜야 합니다. 클래스를 확장해야 할 명확한 이유가 없으면 아이템17에서 다뤘던 방식으로 상속을 금지합시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item19/","summary":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.\n상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.","title":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라"},{"content":"[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.\n상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.\n예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.out.println(\u0026#34;hello\u0026#34;); return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } }   1 2 3  CustomHashSet\u0026lt;String\u0026gt; set = new CustomHashSet\u0026lt;\u0026gt;(); set.addAll(Arrays.asList(\u0026#34;가\u0026#34;,\u0026#34;나\u0026#34;,\u0026#34;다\u0026#34;)); System.out.println(set.getAddCount());   원소를 3개 삽입했지만 getAddCount를 출력하면 결과값은 6이 나옵니다.\n디버깅을 해본 결과 상위 클래스에서 addAll메서드에서 add를 호출하는데 여기서 add는 오버라이딩 된 add메서드를 결과적으로 3번 더 호출하게 됐습니다.\n추가로 다음 릴리즈에서 상위 클래스에 새로운 메서드를 추가했는데, 하필 하위 클래스에 추가한 메서드와 시그니처가 같고 반환 타입이 다를 경우 컴파일조차 되지 않습니다.\n이러한 문제점들은 컴포지션을 통해서 쉽게 피해갈 수 있습니다. 컴포지션은 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조해서 이용할 수 있습니다.\n상속은 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 합니다.\n클래스 B가 A를 상속하기 전에 B가 A인가? 자문해보고 \u0026ldquo;그렇다\u0026quot;라는 확신이 들지 않으면 컴포지션(has-a) 을 이용하는 게 좋습니다.\n컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴입니다.\n그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한됩니다. 더 심각한 문제는 클라이언트가 노출된 내부에 직접 접근 할 수 있다는 점입니다.\n컴포지션 대신 상속을 사용하기로 결정하면 마지막으로 자문해야 될 질문이 있습니다.\n\u0026ldquo;확장하려는 클래스의 API에 아무런 결함이 없는가\u0026rdquo; 결함이 있다면, 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가?\n상속은 상위 클래스의 API를 그 결함까지도 그대로 승계합니다.\n정리  상속은 강력하지만 캡슐화를 해친다는 단점이 있습니다. 상속은 상위 클래스와 하위클래스가 순수한 is-a 관계일 때만 사용해야합니다. 상속의 단점을 피하려면 컴포지션을 활용합시다.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item18/","summary":"[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.\n상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.\n예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.","title":"[아이템 18] 상속보다는 컴포지션을 사용하라"},{"content":"[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점\n클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.x = x; this.y = y; } public Calculator plus(Calculator c) { return new Calculator(x + c.x, y + c.y); } public Calculator minus(Calculator c) { return new Calculator(x - c.x, y - c.y); } ... 생략 }   여기서 주목할 점은 메서드들이 인스턴스 자신을 수정하지 않고 새로운 Calculator 인스턴스를 만들어 반화하는 것입니다.\n불변 객체의 장점  불변 객체는 Thread-Safe 하므로 멀티 쓰레드 환경에서 안전하게 사용할 수 있습니다. 불변 객체는 하나의 상태만을 갖고 있으므로 데이터를 신뢰할 수 있습니다.  따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용 하길 추천합니다. 재활용 하기 가장 쉬운 방법은 자주 쓰이는 값들을 상수로 제공하는 것입니다.\n1 2  public static final Calculator ONE = new Calculator(1, 0); ...   이 방식을 더 살펴보면 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있습니다. 대표적으로 박싱된 기본 타입 클래스가 있습니다.이런 정적 팩터리를 사용하면 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어듭니다. 하지만 붋변 객체에도 단점이 있습니다.값이 다르면 반드시 독립된 객체로 만들어야 합니다. (성능 이슈)\n불변 클래스를 만드는 설계 방법 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야하는데 가장 쉬운 방법은 final으로 선언해주는 것입니다. 하지만 이것보다 더 유연한 방법이 있습니다. 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 펙터리를 제공하는 방법입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public final class Calculator { private final int x; private final int y; private Calculator(int x, int y) { this.x = x; this.y = y; } public static Calculator valueOf(int x, int y) { return new Calculator(x, y); } ... }   정적 팩토리 방식으로 다수의 구현 클래스를 활용해 유연성을 제공하고, 객체 캐싱 기능을 추가해 성능을 끌어올리 수 있습니다.BigInteger와 BigDecimal의 주의점 두 클래스를 설계할 당시 불변 객체가 final이어야 한다는 인식이 없었습니다. 그래서 두 클래스의 메서드들은 모두 재정의할 수 있게 설계 되었고 하위 호환성이 발목을 잡아 지금까지도 이 문제를 고치지 못했습니다. 그러므로 신뢰할 수 없는 클라이언트로부터 BigInteger와 BigDecimal의 인스턴스를 인수로 받는다면 주의해야 합니다.\n1 2 3 4  public static BigInteger safeInstance(BingInteger val) { return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray()); }   ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item17/","summary":"[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점\n클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.","title":"[아이템 17] 변경 가능성을 최소화하라"},{"content":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } }   외부에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 변경할 수 있는 유연성을 얻을 수 있습니다. public 클래스의 불변이라면 직접 노출할 때의 단점이 줄어들지만 여전히 문제점은 있습니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점이 있습니다. 하지만 불변식은 보장할 수 있습니다.\n정리  public 클래스의 가변 필드는 절대 노출해서는 안 됩니다. 불변 필드라면 위험은 덜 하지만 완전히 안심할 수는 없습니다. 하지만 package-private 클래스나 private 중첩 클래스에서는 필드를 노출하는 편이 나을 때도 있습니다.\n ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item16/","summary":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.","title":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라"},{"content":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.\n정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다. (다른 컴포넌트에 영향을 주지 않고 특정 컴포넌트만 최적화 할 수 있어서) 재사용성을 높입니다. (독자적으로 동작하는 컴포넌트는 다른 환경에서도 쓰일 수 있기 때문에)  접근 제어자를 잘 활용하는 것이 정보 은닉의 핵심입니다.가본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁혀야 합니다. 즉 애플리케이션이 제대로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 합니다.톱레벨(가장 바깥) 클래스와 인터페이스에 부여할 수 있는 접근 제어자는 public과 package-private(default) 두 가지 입니다. public으로 선언하면 공개 API가 되므로 패키지 외부에서 쓸 일이 없다면 package-private로 선언하는 걸 권장합니다.한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static으로 중첩시켜봅시다. 이렇게 하면 바깥 클레스 하나에서만 접근할 수 있습니다. 멤버(필드, 메섣, 중첩 클래스, 중첩 인터페이스)에 사용할 수 있는 접근제한자\n private: 멤버를 선언한 톱레벨 클래스에서만 접근 가능합니다. package-private: 멤버가 소속된 패키지안에 모든 클래스에서 접근 가능합니다 protected: package-private + 하위 클래스 public: 모든 곳에서 접근할 수 있습니다.  public 클래스의 인스턴스 필드는 가능한 public이 아니어야 합니다. 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스필드를 public으로 선언하면 필드의 내용이 수정될 수 있으므로 불변을 보장할 수 없게 되므로 유의해야 합니다. 필드가 final이면서 불변 객체를 참조해도 문제는 있습니다. 내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링 할 수 없게 됩니다.정적 필드 같은 경우 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final필드로 공개해도 좋으나 반드시 primitive type이나 불변 객체를 참조해야 합니다. 가변 객체를 참조한다면 참조는 변경하지 못하나 객체 값은 수정될 수 있으므로 주의해야 합니다.정리  프로그램의 접근 제어자는 가능한 최소한으로 합시다. 꼭 필요한 것만 public API를 설계하고 그 외에는 의도치 않게 API로 공개되는 일이 없도록 해야 합니다. public클래스는 public static final 필드 외에는 어떠한 public 메서드도 가져서는 안 됩니다. 또한 public static final 필드가 참조하는 객체가 불변인지 확인합시다.\n ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-03/item15/","summary":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.\n정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다.","title":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라"},{"content":"[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다.\nComparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.\n그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.\n1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다. 이 객체와 비교할 수 없는 타입이면 ClassCastException을 던집니다.\n다음 설명에서는 sgn(표현식) 표기는 수학에서 말하는 부호 함수를 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환하도록 정의했습니다.\n  Comparable을 구현한 클래스는 모든 x, y에 대해,\nsgn(x.comparaTo(y)) == -sgn(y.comparaTo(x))여야 합니다.\n따라서 sgn(x.comparaTo(y))는 -sgn(y.comparaTo(x))가 예외를 던질 때에 한해 예외를 던져야 합니다.\n  Comparable을 구현한 클래스는 추이성을 보장해야 합니다.\nx.comparaTo(y) \u0026gt; 0 \u0026amp;\u0026amp; y.comparaTo(z) \u0026gt; 0이면 x.compareTo(z) \u0026gt; 0입니다.\n  Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))입니다.\n  이번 권고가 필수는 아니지만 꼭 지키는 게 좋습니다. (x.compareTo(y) == 0) == (x.equals(y))여야 합니다.   hashCode 규약을 지키지 못하면 해시를 사용하는 클래스에서 오작동이 날 수 있듯이 compareTo 규약을 지키지 못하면 TreeSet, TreeMap과 같이 비교를 활용하는 클래스에서 오작동이 날 수 있습니다.\nCompareble 인터페이스은 타입 인수를 받는 제네릭 인터페이스므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해집니다. 즉 매개변수 타입이 잘못 됐다면 컴파일 자체가 되지 않으므로 형변환 할 필요가 없다는 뜻입니다.\n객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출합니다. Compareble을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 Comparator를 사용하면 됩니다.\n클래스의 핵심 필드가 여러개라면 가장 핵심적인 필드부터 비교하는 것을 추천드립니다. 비교 결과가 0이 아니라면 순서는 거기서 셜정되기 떄문입니다. JAVA 8에서 compareTo 메서드를 구현하기\n1 2 3 4 5 6 7 8 9 10 11  List\u0026lt;Student\u0026gt; students = Arrays.asList( new Student(30, \u0026#34;kim\u0026#34;), new Student(50, \u0026#34;jake\u0026#34;), new Student(50, \u0026#34;foo\u0026#34;) ); students.sort( Comparator.comparingInt(Student::getAge) .thenComparing(Student::getName) ); // 이뿐만 아니라 다양한 방식으로 정렬을 할 수 있습니다.   위와 같이 코드를 간결하게 짤 수 있습니다. 대신 약간의 성능 저하가 있습니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-02/item14/","summary":"[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다.\nComparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.\n그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.\n1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다.","title":"[아이템 14] Comparable를 구현할지 고려하라"},{"content":"[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다. 하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다.\n이 객체의 복사본을 생성해 반환합니다. \u0026lsquo;복사\u0026rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.\n x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다. Cloneable인터페이스를 구현하고 super.clone을 호출하면 됩니다. 이렇게 얻은 객체는 원본의 모든 필드랑 똑같은 값을 가지게 됩니다.\n1 2 3 4 5 6 7 8  @Override public PhoneNumber clone() { try{ return (PhoneNumber) super.class(); } catch (CloneNotSupportedException e) { throw new AssertionsError(); } }   Obejct의 clone은 Object를 반환하지만 공변 반환 타입을 이용해서 PhoneNumber로 반환했습니다. 이 방식으로 사용하는 클라이언트는 형변환을 따로 해줄 필요가 없습니다.\n간단했던 앞서의 구현이 클래스가 가변 객체를 참조하는 순간 문제점이 발생합니다.\n1 2 3 4 5 6 7 8 9 10 11  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } ... 생략 }   clone 메서드가 단순히 super.clone의 결과를 그대로 반환하면 Stack인스턴스의 size 필드는 올바른 값을 갖겠지만, elements필드는 원본 Stack 인스턴스와 똑같은 배열을 참조하게 되는 상황이 발생합니다.\nclone메서드는 사실상 생성자와 같은 효과를 냅니다. 즉 clone은 원본 객체에 아무런 변화가 없는 동시에 복제된 객체의 불변식을 보장해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11  // 가변 상태를 참조하는 클래스용 clone 메서드 @Override public PhoneNumber clone() { try{ Stack result = (Stack) super.clone(); result.elements = elements.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionsError(); } }   ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-02/item13/","summary":"[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다. 하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다.\n이 객체의 복사본을 생성해 반환합니다. \u0026lsquo;복사\u0026rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.\n x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다.","title":"[아이템 13] clone 재정의는 주의해서 진행하라"},{"content":"[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다.\n이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.\n1 2  Student student = new Student(\u0026#34;kim\u0026#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.\ntoString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다. 이러한 문제는 롬복으로 해결할 수 있습니다.   포맷을 명시하든 아니든 여러분의 의도는 명확하게 밝혀져야합니다. toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공합시다.  정리 객체의 정보를 출력할 일이 있으면 toString을 재정의 합시다. toString을 재정의하면 사용자가 보기 편하고 디버깅을 쉽게 해줍니다. toString은 객체에 관해 명확하고 정보를 읽기 좋은 형태로 반환해야합니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-02/item12/","summary":"[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다.\n이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.\n1 2  Student student = new Student(\u0026#34;kim\u0026#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.\ntoString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다.","title":"[아이템 12] toString을 항상 재정의하라"},{"content":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.\n equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아집니다.  서로 다른 인스턴스에 대해서 모두 다른 해시코드를 반환하면 좋겠지만 hashCode는 int형이므로 2^32만큼의 경우의 수로 제한되어 있기 때문에 비둘기 집의 원리로 예외가 생길 수 있습니다. 다음은 hashCode를 작성하는 요령입니다.\n  int 변수 result를 선언한 후 값 c로 초기화 합니다. 이때 c는 해당 객체의 첫번째 해시 필드를 2-a 방식으로 계산한 해시코드입니다.   나머지 개개의 필드 f 각각에 대해서 다음 작업을 수행합니다. a. 해당 필드의 해시코드 c를 계산합니다.\n 기본 타입 필드라면, Type.hashCode(f)를 수행합니다. 여기서 Type은 해당 기본 타입의 박싱 클래스입니다. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출합니다. 필드가 배열이라면, 원소 각각을 별도 필드처럼 다룹니다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 2.b방식으로 갱신합니다. 배열에 핵심 원소가 하나도 없다면 단순 상수를 사용하고 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용합니다.  b. 2.a에서 계산한 해시코드 c로 result를 갱신합니다.\n result = 31 * result + c;     result를 반환합니다. equals 비교에서 사용되지 않는 필드는 반드시 제외해야 합니다. 그렇지 않으면 맨 처음에 언급했던 두 번째 규약을 어기게됩니다.\n  숫자를 곱하는 이유는 만약 곱셉 없는 hahCode를 구현하게 되면 모든 아나그램의 해시코드가 같아집니다. 그리고 31을 선택한 이유는 홀수이면서 소수이기 때문입니다.\n1 2 3 4 5 6 7 8  // 전형적인 hashCode 메서드 @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; }   1 2 3 4 5  // 한 줄짜리 hasoCode 메서드 - 성능이 살짝 아쉽습니다. @Override public int hashCode(){ return Objects.hash(lineNum, prefix, areaCode); }   정리 equals를 재정의 할 때는 hashCdoe도 재정의해야 합니다. 그렇지 않으면 프로그래밍이 제대로 동작하지 않을 수 있습니다. 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 합니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-02/item11/","summary":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.\n equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아집니다.","title":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라"},{"content":"[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.\nequals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다.\n반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class CaseInsensitiveString { private String str; ... 생략 @Override public boolean equals(Object o) { if (o instanceof CaseInsensitiveString) { return str.equalsIgnoreCase(((CaseInsensitiveString) o).str); } if (o instanceof String) { return str.equalsIgnoreCase((String) o); } return false; } }   1 2  CaseInsensitiveString cis = new CaseInsensitiveString(\u0026#34;String\u0026#34;); String str = \u0026#34;string\u0026#34;;   cis.equals(str)는 true를 반환하고 str.equals(cis)는 false를 반환하게 되므로 대칭성에 위반됩니다.\n추이성(transitivity)  null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true고 y.equals(z)도 true입니다.  일관성(consistency)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환해야 합니다.  null-아님  null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다  이제 상위 클래스에 없는 필드를 하위 클래스에 추가하는 상황을 생각해봅시다. 여기서부터 신경써야 할 부분들이 많아집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Point { private int x; private int y; ... 생략 @Override public boolean equals(Object o) { if (!(o instanceof Point)) { return false; } Point p = (Point) o; return this.x == p.x \u0026amp;\u0026amp; this.y == p.y; } }   Point클래스를 확장해봅시다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class CirclePoint extends Point{ private int x; private int y; private int z; public CirclePoint(int x, int y, int z) { super(x, y); this.z = z; } ... 생략 }   이대로 사용하면 Point의 구현이 상속되어 x, y만 비교하게 되므로 생각했던 결과랑 실제 결과값이 다르게 나오는 상황이 발생합니다.객체 지향의 추상화의 이점을 포기하지 않는 이상 아쉽게도 이러한 문제점들을 모두 완전하게 해결할 수 있는 방법은 없습니다.\n양질의 equals메서드 구현 단계  == 연산자를 사용해 입력이 자기 자신의 참조인지 확인합니다. insetanceof 연산자로 입력이 올바른 타입인지 확인합니다. 입력을 올바른 타입으로 형변환 합니다. 입력받은 객체와 자기 자신의 대응되는 필드들이 모두 일치하는지 검사합니다.  어떤 필드를 먼저 비교하느냐에 따라 성능의 차이도 생깁니다. 값이 다를 가능성이 크거나 비교하는 비용이 싼 필드를 먼저 비교하면 성능상 이점을 얻을 수 있습니다.(틀리면 다음 로직을 실행하지 않기에)\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-02/item10/","summary":"[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.\nequals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다.\n반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반","title":"[아이템 10] equals는 일반 규약을 지켜 재정의하라"},{"content":"[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 close를 해야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다. 위 예제 같은 경우 try 블록과 finally 블록 모두에서 발생할 수 있는데, 예컨데 기기에 물리적 문제가 생긴다면 firstLineOfFile 메서드 안의 readLine 메서드가 예외를 던지고, 같은 이유로 close 메서드도 실패합니다. 이런 상황이라면 두 번째 예외가 첫 번째 예외를 완전히 집어삼키게 됩니다. (첫 번째 예외는 정보가 남지 않게 됩니다.)\n이러한 문제점들을 고안해서 JAVA 7부터는 try-with-resources으로 해결할 수 있습니다. 이 구조를 사용하려면 해당 자원이 AutoCloseable 인터페이스를 구현해야 합니다. 자바 라이브러리와 서드파티 라이브러리들의 수많은 클래스와 인터페이스가 이미 Autocloseable을 구현하거나 확정했습니다.\ntry-with-resources를 사용한 코드\n1 2 3 4 5  static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } }   try-with-resources에서도 catch 절을 사용할 수 있습니다.\n1 2 3 4 5 6 7  static String firstLineOfFile(String path) { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultVal; } }   ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item9/","summary":"[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 close를 해야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다.","title":"[아이템 9] try-finally보다는 try-with-resources를 사용하라"},{"content":"[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.\ncleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.\n단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.\nfinalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다. finalizer 쓰레드는 우선 순위가 낮아서 실행될 기회를 제대로 얻지 못하는 경우들도 생깁니다.\n수행 여부가 보장되지 않습니다 자바 언어 명세는 finalizer와 cleaner의 수행 시점과 수행 여부조차 보장하지 않습니다. 따라서 상태를 수정하는 작업에는 절대 finalizer나 cleaner에 의존해서는 안 됩니다.\n예외가 무시됩니다. finalizer가 동작하면서 발생한 예외는 무시되며 처리할 작업이 남아있더라도 그 순간 종료됩니다. finalzer같은 경우 예외가 발생해도 추적을 할 수 없으며 이는 디버깅하는데 큰 문제가 됩니다.\n성능상 이슈 Autocloseable 객체를 만들고 가비지 컬렉터가 수거하기 전까지 12ns가 걸린 반면, finalizer를 사용하면 550ns가 소요 됐습니다. finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문입니다.\n뿐만 아니라 다양한 이슈들로 인해 finalizer와 cleaner의 사용을 추천하고 있지 않습니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item8/","summary":"[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.\ncleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.\n단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.\nfinalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다.","title":"[아이템 8] finalizer와 cleaner 사용을 피하라"},{"content":"[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size); } }   스택에서 데이터를 pop을 실행해도 메모리는 줄어들지 않습니다. 왜냐면 size를 감소 시키지만 배열에서 여전히\u001d 레퍼런스는 그대로 갖고있기 때문입니다.\n다음과 같이 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9  public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object value = this.elements[--size]; this.elements[size] = null; return value; }   size를 감소시킬 뿐만 아니라 실제로 해당 참조를 null로 처리한 방법입니다.\n하지만 객체 처리를 null로 처리하는 건 예외적인 경우여야 합니다. 다 쓴 참조를 해제하는 가장 좋은 방법은 다 쓴 참조를 담은 변수를 특정한 스코프 안에서만 사용하는 것입니다.\n캐시를 사용할 때도 메모리 누수에 유의해야 합니다.\n 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 필요하다면 WeakHashMap을 사용합니다. 시간이 지날 수록 엔티리의 가치를 떨어뜨리는 방식.  ","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item7/","summary":"[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.","title":"[아이템 7] 다 쓴 객체 참조를 해제하라"},{"content":"[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.\n문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(\u0026#34;hello\u0026#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.\n리터럴 방식 1  String str = \u0026#34;hello\u0026#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.\n생성 비용이 비싼 객체 생성 비용이 비싼 객체들 같은 경우 캐싱해서 재사용할 수 있는 방법을 고려해보는 게 좋습니다.\n불필요한 객체 생성 1 1 2 3 4  static boolean isRomanNumeral(String s) { return s.matches(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})\u0026#34; + \u0026#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); }   정규표현식의 예제로 문자열이 로마 숫자인지 확인하는 코드입니다.\nString.matches는 내부에서 만드는 Pattern객체를 만들어서 사용하는데, 이 메서드에서는 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 됩니다. 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 생성 비용이 비쌉니다.\n해결책 1 2 3 4 5 6 7 8 9  public class RomanNumber { private static final Pattern ROMAN = Pattern.compile(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); } }   성능을 개선한 코드 수정입니다.Pattern인스턴스 클래스 초기화 과정에서 직접 생성하고 캐싱해두었다가 해당 isRomanNumeral가 호출될 때마다 인스턴스를 재사용합니다. isRomanNumeral가 여러변 호출되는 상황에서 성능을 상당히 끌어올릴 수 있습니다.\n어댑터 어댑터는 인터페이스를 통해서 다른 객체의 연결해주는 객체라 여러개 만들 필요가 없습니다.\n대표적으로 Map 인터페이스에 있는 keySet 메서드는 호출 될 때마다 새로운 객체가 나오는 게 아니라 같은 객체를 반환하기 때문에 리턴받은 Set 타입의 객체를 변경하면, 결국 그 뒤에 있는 Map 인터페이스도 변경되는 것입니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item6/","summary":"[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.\n문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(\u0026#34;hello\u0026#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.\n리터럴 방식 1  String str = \u0026#34;hello\u0026#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.","title":"[아이템 6] 불피요한 객체를 생성을 피하라"},{"content":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.\n부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = ...; private SpellChecker() { } public static SpellChecker INSTANCE = new SpellChecker(); public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { ... } }   여기서 말하는 유연함이란 구현체를 변경하는 용이성을 말합니다.\n사용하는 리소스에 따라 행동을 다르게 해야하는 클래스는 위에 말한 두 방식을 사용하는 것은 부적절합니다. 이러한 불편 사항들을 해결하기 위해서는 인스턴스를 생성할 때 생성자에 자원을 넘겨주는 방식이 있습니다.\n적절한 구현 의존 객체 주입은 유연성과 테스트 용이성을 높입니다. 1 2 3 4 5 6 7 8 9 10 11 12  public class SpellChecker { private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) { this.dictionary = dictionary; } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   흔히 생성자 주입 방식이라고 부르고 이러한 방식은 불변을 보장하며 원하면 하위 타입 인스턴스의 다양한 구현체를 주입할 수 있습니다.\n위와 같이 의존성을 주입하는 방식은 유연함과 테스트 용이함을 크게 향상시켜 주지만, 의존성이 많아질 경우 코드가 장황해질 수 있습니다.\n하지만 이 점은 스프링 같은 프레임워크로 해결할 수 있습니다. 요약하자면 의존하는 리소스에 따라 행동을 달리하는 클레스를 사용할 때는 싱글턴이나 스태틱 유틸클래스를 사용하지말고 리소스를 생성자를 통해 의존성을 주입받는 걸 추천합니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item5/","summary":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.\n부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = .","title":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라"},{"content":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.\n매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.\n1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item4/","summary":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.\n매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.\n1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.","title":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라"},{"content":"[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.\n싱글턴을 만드는 방식은 보통 둘 중 하나입니다.\npublic static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { ... } }   public이나 protected 생성자가 없으므로 Elvis 클래스가 초기화 될 때 만들어진 인스턴스는 하나 뿐입니다. 단 권한이 있는 클라이언트는 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있습니다. public 필드 방식의 첫번째 장점은 해당 클래스가 싱글턴임이 API에 명백히 드러나는 것입니다.\n두 번째 장점은 간결하다는 것입니다. 이 점은 생성자를 수정하여 두 번째 객체가 생성되려고 하면 예외를 단지면 됩니다.\n싱글턴을 만드는 두 번째 방법에는 정적 팩토리 메서드를 public static 멤버로 제공합니다.\n정적 팩토리 방식의 싱글톤 1 2 3 4 5 6 7 8 9 10 11  public class Elvis { private static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } public static Elvis getInstance() { return INSTANCE; } private void leaveTheBuilding() { ... } }   이 역시 리플렉션을 통한 예외는 똑같이 적용됩니다.\n장점\n API를 바꾸지 않고 싱글턴이 아니게 변경할 수 있습니다. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있습니다. 정적 팩토리 메서드 참조를 공급자(supplier)로 사용할 수 있습니다.  위에서 살펴본 두 방법 모두 직렬화하려면 모든 인스턴스 필드를 일시적(transient)이라고 선언하고 readResolve 메서드를 다음과 같이 제공해야 합니다.\n1 2 3  private Object readResolve() { returm INSTANCE; }   이렇게 하지 않으면 역직렬화 할때마다 새로운 인스턴스가 생성됩니다.\n열거 타입의 방식의 싱글턴 1 2 3 4 5  public enum Elvis { INSTANCEl public void leaveTheBuilding() { ... } }   직렬화 상황 그리고 리플렉션 공격에서도 싱글턴임을 보장할 수 있습니다. 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법입니다.\n하지만 이 방법은 Enum 외의 클래스를 상속해야한다면 사용할 수 없습니다.(인터페이스를 구현할 수는 있습니다)\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item3/","summary":"[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.\n싱글턴을 만드는 방식은 보통 둘 중 하나입니다.\npublic static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { .","title":"[아이템 3] private 생성자나 열거 타입으로  싱글턴임을 보증하라"},{"content":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.\n첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.\n두번째 대안: 자바빈 또 다른 대안으로는 매개변수가 없는 생성자를 만든 뒤 setter를 통해서 값을 설정한는 방법입니다.\n1 2 3 4 5 6  Nutritionfact cocaCola = new Nutritionfact(); cocaCola.setServingSize(240); cocaCola.setServings(8); cocaCola.setCalories(100); .. 반복   생성자를 이용한 방식보다 가독성이 훨씬 올라갔습니다. 하지만 객체가 완전히 생성되기 전까지는 중간에 사용할 수도 있으므로 일관성을 유지할 수 없습니다. 또한 불변 클래스로 만들 수 없다는 단점도 있으며(쓰레드 세이프하지 않습니다) 이를 해결하려면 추가 작업을 해줘야 합니다.\n세번째 대안: 빌더 발더 패턴은 필요한 매개변수만 전달할 수 있고 자바빈즈 패턴의 가독성을 모두 겸비한 대안입니다. 필수 매개변수만으로 생성자(혹은 정적팩토리)를 호출해 빌더 객체를 얻습니다.그 후 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수를 설정합니다.\n마지막으로 매개변수가 없는build메서드를 호출하여 객체를 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // 예제에서 사용한 Builder패턴  public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; public static class Builder { // 필수 매개변수  private final int servingSize; private final int servings; // 선택 매개변수 - 기본값으로 초기화 한다.  private int calories = 0; private int fat = 0; private int sodium = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this; } public Builder fat(int val) { fat = val; return this; } public Builder carbohydrate(int val) { sodium = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder) { this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; } }   1 2 3 4 5  NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100) .sodium(35) .carbohydrate(27) .build();   아까보다 가독성도 좋아지고 NutritionFacts 클래스는 불변이 되었습니다. 추상 클래스는 추상 빌더를 갖게하고 구체 클래스는 구체 빌더를 갖게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set\u0026lt;Topping\u0026gt; toppings; abstract static class Builder\u0026lt;T extends Builder\u0026lt;T\u0026gt;\u0026gt; { EnumSet\u0026lt;Topping\u0026gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // Pizza를 상속한 인스턴스를 반환하기만 하면 된다.  // 하위 클래스는 이 메서드를 재정의 하여 \u0026#34;this\u0026#34;를 반환하도록 해야 한다.  protected abstract T self(); } Pizza(Builder\u0026lt;?\u0026gt; builder) { toppings = builder.toppings.clone(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class NyPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private final Size size; public static class Builder extends Pizza.Builder\u0026lt;Builder\u0026gt; { private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Override Pizza build() { return new NyPizza(this); } @Override protected Builder self() { return this; } } private NyPizza(Builder builder) { super(builder); size = builder.size; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Calzone extends Pizza { private final boolean sauceInside; public static class Builder extends Pizza.Builder\u0026lt;Builder\u0026gt; { private boolean sauceInside = false; public Builder sauceInde() { sauceInside = true; return this; } @Override public Calzone build() { return new Calzone(this); } @Override protected Builder self() { return this; } } private Calzone(Builder builder) { super(builder); sauceInside = builder.sauceInside; } }   build 메서드는 하위 클래스 어떤 걸 반환해도 상관 없습니다. 하위 메서드가 상위 클래스의 메서드 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공반환 타이핑이라 합니다.\n1 2 3 4 5  Pizza pizza = new Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInde().build();   빌더는 다양한 방식으로 객체를 생생할 수 있으므로 생성자와 정적 팩토리 메서드 방식보다 상당히 유연합니다.\n단점으로는 객체를 생성하려면 Builder()를 생성해야하는데 성능에 민감한 상황에서는 이 점이 문제가 될 수 있습니다.그리고 생성자에 비해서 코드가 장황에 질 수 있으므로 현재 필요한 매개변수와 확장성을 고려해서 잘 판단하면 될 거 같습니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item2/","summary":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.\n첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.","title":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려하라"},{"content":"[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드\n1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.\n반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.\n하나의 시그니처로는 생성자를 하나만 만들 수 있으며 입력 매개변수들의 순서를 다르게 한 생성자를 추가하는 식으로 이 제한을 피할 수는 있지만,이 역시 객체의 특성을 살리기 힘들고 좋지 않은 방식입니다.\n정적 팩토리 메소드는 이러한 제약이 없으며 시그니처가 같은 생성자가 여러 개 필요할 거 같으면\n생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어내는 방법을 사용할 수 있습니다.\n2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불변 클래스(immutable class)는 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있습니다. 따라서 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어 올릴 수 있습니다. Boolean.valueOf(boolean) 메소드도 그 경우에 해당됩니다.\n3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 반환할 객체의 클래스를 선택할 수 있는 유연함이 있습니다. 리턴 타입의 하위 타입의 인스턴스를 반환할 수 있으므로 가능합니다. API를 만들때 유연성을 이용하여 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있습니다. 자바 컬렉션 프레임워크는 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 덧붙인\n총 45개의 유틸리티구현체를 제공하는데, 이 구현체는 대부분 단 하나의 인스턴스화 불가 클래스인java.util.Collections에서 정적 팩터리 메소드를 통해 얻도록 했습니다. 컬렉션 프레임워크는 이 45개의 클래스를 공개하지 않기 때문에 API의 외견을 훨씬 작게 만들 수 있었습니다.\n여기서 무게는 프로그래머가 API를 사용하기 위해 익혀야하는 개념의 수와 난이도를 맗합니다.\n클라이언트가 구현체가 아닌 인터페이스를 다루게 되므로 역할과 구현이 나눠지므로 결합도가 낮출 수 있습니다.\n4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 장점 3에서 말했듯이 하위 타입이기만 하면 어떤 클래스의 객체를 반환하던 상관 없습니다.\n가령 EumSet 클래스는 public 생성자 없이 오직 정적 펙토리 메서드만 제공합니다. nonOf 등..\nnonOf 메서드를 살펴보면 원소 수에 따라 RegularEnumSet 이나 JumbEnumSet 인스턴스를 반환 합니다.\n1 2 3 4 5 6 7 8 9 10  public static \u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; EnumSet\u0026lt;E\u0026gt; noneOf(Class\u0026lt;E\u0026gt; elementType) { Enum\u0026lt;?\u0026gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \u0026#34; not an enum\u0026#34;); if (universe.length \u0026lt;= 64) return new RegularEnumSet\u0026lt;\u0026gt;(elementType, universe); else return new JumboEnumSet\u0026lt;\u0026gt;(elementType, universe); }   5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 대표적인 프레워크로는 JDBC가 있습니다. 구현체들은 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해줍니다.\n서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어집니다. (제공자는 서비스의 구현체를 의미합니다)\n 서비스 인터페이스 (구현체의 동작을 정의) 제공자 등록 API (제공자가 구현체를 등록할 때 사용) 서비스 접근 API (클라이언트가 서비스의 인스터스를 얻을 때 사용)  서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있습니다. 조건을 명시하지 않으면 기본 구현체를 반화하거나 지원하는 구현체들을 하나씩 돌아가면서 반환합니다.\n단점 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다 이 제약은 상속보다is-a 컴포지션을has-a 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있습니다.\n2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 생성자처럼 API설명에 명확히 드러나지 않으므로 사용자는 정적 팩토리 메서드 사용 방식 클래스를 인스턴스화 시킬 방법을 알아내야 합니다. 그러므로 API 문서를 잘 정리하고 메서드 이름도 널리 알려진 규약을 따르는 게 좋습니다.\n","permalink":"https://qutrits.github.io/en/posts/effective-java-3e/chapter-01/item1/","summary":"[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드\n1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.\n반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.","title":"[아이템 1] 생성자 대신 정적 팩토리 메서드를 고려하라"}]