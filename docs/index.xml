<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>&lt;Qutrits/&gt;</title>
    <link>https://qutrits.github.io/</link>
    <description>Recent content on &lt;Qutrits/&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 13 Dec 2021 17:46:19 +0900</lastBuildDate><atom:link href="https://qutrits.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>배너를 만들어보자!</title>
      <link>https://qutrits.github.io/posts/dummy/studying15_snap/</link>
      <pubDate>Mon, 13 Dec 2021 17:46:19 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying15_snap/</guid>
      <description>아래 이미지는 만든 배너의 모습이다. UI리소스는 친구가 만들어줬다..ㅎㅎ
💚 만들면서 고민한 것들.
 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!
 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.
 Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 2667</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm19_2667/</link>
      <pubDate>Sun, 12 Dec 2021 23:15:57 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm19_2667/</guid>
      <description>알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에&amp;hellip;ㅎㅎ
알고리즘 공부 백준 2667 🧐 제로 👉문제 &amp;lt;그림 1&amp;gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다.</description>
    </item>
    
    <item>
      <title>GarbageCollection: 가비지 컬렉션</title>
      <link>https://qutrits.github.io/posts/dummy/studying14_gc/</link>
      <pubDate>Tue, 07 Dec 2021 20:21:53 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying14_gc/</guid>
      <description>가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.
그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.
힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다.</description>
    </item>
    
    <item>
      <title>타이머를 이용해 스킬아이콘을 만들어보자!</title>
      <link>https://qutrits.github.io/posts/dummy/studying13_timer/</link>
      <pubDate>Mon, 06 Dec 2021 15:58:16 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying13_timer/</guid>
      <description>🍑 타이머
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action&amp;lt;float&amp;gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action&amp;lt;float&amp;gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!</description>
    </item>
    
    <item>
      <title>Tween 만들기 프로젝트 근황</title>
      <link>https://qutrits.github.io/posts/dummy/studying12_tweenmaking/</link>
      <pubDate>Mon, 06 Dec 2021 15:34:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying12_tweenmaking/</guid>
      <description>애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.
🍑 핑퐁 기능 추가!!!!
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!</description>
    </item>
    
    <item>
      <title>inheritance: 상속</title>
      <link>https://qutrits.github.io/posts/dummy/studying11_inheritance/</link>
      <pubDate>Mon, 06 Dec 2021 00:25:53 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying11_inheritance/</guid>
      <description>상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.
💚 예시 오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다.</description>
    </item>
    
    <item>
      <title>abstract class: 추상클래스</title>
      <link>https://qutrits.github.io/posts/dummy/stuying10_abstract/</link>
      <pubDate>Thu, 02 Dec 2021 23:13:57 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/stuying10_abstract/</guid>
      <description>오늘은 추상 클래스에 대해 알아보쟈!
abstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.
💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, &amp;ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.&amp;rdquo; 라는 계약이 생긴다.</description>
    </item>
    
    <item>
      <title>interface: 인터페이스</title>
      <link>https://qutrits.github.io/posts/dummy/studying9_interface/</link>
      <pubDate>Wed, 01 Dec 2021 20:57:53 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying9_interface/</guid>
      <description>interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.
Can Do를 알려주는 역할을 한다.
interface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시 만약 조류라는 클래스가 있다고 하자. 이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다. 하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?
이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).</description>
    </item>
    
    <item>
      <title>BFS: 너비우선탐색, DFS: 깊이우선탐색(2)</title>
      <link>https://qutrits.github.io/posts/dummy/studying8_bfs_dfs2/</link>
      <pubDate>Wed, 01 Dec 2021 20:08:00 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying8_bfs_dfs2/</guid>
      <description>음&amp;hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다. 나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실&amp;hellip;!😱 그래서 오늘 공부해보려고 한다.
BFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.</description>
    </item>
    
    <item>
      <title>BFS: 너비우선탐색, DFS: 깊이우선탐색(1)</title>
      <link>https://qutrits.github.io/posts/dummy/studying7_bfs_dfs/</link>
      <pubDate>Mon, 29 Nov 2021 21:40:04 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying7_bfs_dfs/</guid>
      <description>음&amp;hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다&amp;hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서.. 원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋
Graph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.
 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법
 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i &amp;lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List&amp;lt;int&amp;gt;[] Graph = new List&amp;lt;int&amp;gt;[V + 1]; for (int i = 1; i &amp;lt; N + 1; i++) { Graph[i] = new List&amp;lt;int&amp;gt;(); foreach(v in AdjacencyVertices) { Graph[i].</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 10773</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm15_10773/</link>
      <pubDate>Fri, 26 Nov 2021 23:48:46 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm15_10773/</guid>
      <description>알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.
재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.
재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.
재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!
👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)</description>
    </item>
    
    <item>
      <title>Draw Call: 드로우콜(3)</title>
      <link>https://qutrits.github.io/posts/dummy/studying6_drawcall3/</link>
      <pubDate>Fri, 26 Nov 2021 22:47:40 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying6_drawcall3/</guid>
      <description>오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다. 하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다. 그리고 그건 불가능한 게 맞다. 하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.
MaterialPropertyBlock의 활용 🧐  Create -&amp;gt; Shader -&amp;gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 11068</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm14_11068/</link>
      <pubDate>Fri, 26 Nov 2021 00:18:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm14_11068/</guid>
      <description>알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.</description>
    </item>
    
    <item>
      <title>Draw Call: 드로우콜(2)</title>
      <link>https://qutrits.github.io/posts/dummy/studying5_drawcall2/</link>
      <pubDate>Thu, 25 Nov 2021 00:05:33 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying5_drawcall2/</guid>
      <description>이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.
Batch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명
Project Setting &amp;gt; Player 에서 사용이 체크가 되어있는지 확인.  Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법  버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적.</description>
    </item>
    
    <item>
      <title>Draw Call: 드로우콜(1)</title>
      <link>https://qutrits.github.io/posts/dummy/studying4_drawcall1/</link>
      <pubDate>Wed, 24 Nov 2021 23:19:40 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying4_drawcall1/</guid>
      <description>오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!
Draw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명
 오브젝트가 실제 화면에 렌더링 되려면 CPU -&amp;gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재.</description>
    </item>
    
    <item>
      <title>Generic: 제너릭 클래스</title>
      <link>https://qutrits.github.io/posts/dummy/studying3_generic/</link>
      <pubDate>Tue, 23 Nov 2021 23:32:06 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying3_generic/</guid>
      <description>유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.
Generic class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 2941</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm13/</link>
      <pubDate>Tue, 23 Nov 2021 22:12:06 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm13/</guid>
      <description>알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.
예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.
dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.
👉입력 첫째 줄에 최대 100글자의 단어가 주어진다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 4673</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm12/</link>
      <pubDate>Mon, 22 Nov 2021 21:13:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm12/</guid>
      <description>알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.
양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), &amp;hellip;과 같은 무한 수열을 만들 수 있다.
예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다.</description>
    </item>
    
    <item>
      <title>Extenstion Method: 확장 메서드</title>
      <link>https://qutrits.github.io/posts/dummy/studying2/</link>
      <pubDate>Thu, 18 Nov 2021 01:32:38 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying2/</guid>
      <description>유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다. DoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.
나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!
Extenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야?</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 13116</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm11/</link>
      <pubDate>Wed, 17 Nov 2021 23:11:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm11/</guid>
      <description>알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.
하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.
이미지 보러가기
문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1541</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm10/</link>
      <pubDate>Wed, 17 Nov 2021 20:14:27 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm10/</guid>
      <description>알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.
그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.
괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.
👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다.</description>
    </item>
    
    <item>
      <title>Studying_복잡도</title>
      <link>https://qutrits.github.io/posts/dummy/studying1/</link>
      <pubDate>Tue, 16 Nov 2021 02:31:12 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/studying1/</guid>
      <description>시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =&amp;gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  </description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 9461</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm9/</link>
      <pubDate>Mon, 15 Nov 2021 00:26:56 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm9/</guid>
      <description>알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.
파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.
N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>Hugo와 MarkDown: Text Color</title>
      <link>https://qutrits.github.io/posts/dummy/markdown1/</link>
      <pubDate>Sun, 14 Nov 2021 21:31:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/markdown1/</guid>
      <description>블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!
알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.
그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑
그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만&amp;hellip; (막은데에는 이유가 있을거라고 생각하고&amp;hellip;다른 방법을 선택!)
그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode! 참조
Shortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1181</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm8/</link>
      <pubDate>Fri, 12 Nov 2021 23:39:46 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm8/</guid>
      <description>알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.
 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.
👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1929</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm7/</link>
      <pubDate>Fri, 12 Nov 2021 23:39:46 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm7/</guid>
      <description>알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.
👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.
🍑풀이
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 11866</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm6/</link>
      <pubDate>Fri, 12 Nov 2021 04:21:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm6/</guid>
      <description>알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.
1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &amp;lt;3, 6, 2, 7, 5, 1, 4&amp;gt;이다.
N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1920</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm5/</link>
      <pubDate>Fri, 12 Nov 2021 04:21:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm5/</guid>
      <description>알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.
👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.</description>
    </item>
    
    <item>
      <title>c#_string_StringBuilder</title>
      <link>https://qutrits.github.io/posts/dummy/csharp1/</link>
      <pubDate>Fri, 12 Nov 2021 04:21:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/csharp1/</guid>
      <description>C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = &amp;#34;안녕&amp;#34; + &amp;#34;하세요&amp;#34;; //&amp;#34;안녕&amp;#34; &amp;#34;하세요&amp;#34; -&amp;gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -&amp;gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1439</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm4/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm4/</guid>
      <description>알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.
예를 들어 S=0001100 일 때,
 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 1712</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm3/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm3/</guid>
      <description>알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.
예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.
노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>https://qutrits.github.io/posts/dummy/my-first-post/</link>
      <pubDate>Thu, 11 Nov 2021 05:19:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/my-first-post/</guid>
      <description>블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   </description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 11399</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm2/</link>
      <pubDate>Thu, 11 Nov 2021 04:21:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm2/</guid>
      <description>알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.
사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.</description>
    </item>
    
    <item>
      <title>AlgorithmStudy_백준 11720</title>
      <link>https://qutrits.github.io/posts/dummy/algorithm1/</link>
      <pubDate>Thu, 11 Nov 2021 04:21:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/dummy/algorithm1/</guid>
      <description>알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.
👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.
👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.
🍑풀이
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;	public class Program { public static void Main() {	int count = int.</description>
    </item>
    
    <item>
      <title>[아이템 33] 타입 안전 이종 컨테이너를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item33/</link>
      <pubDate>Thu, 09 Jul 2020 18:21:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item33/</guid>
      <description>[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.
1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public &amp;lt;T&amp;gt; void putFavorite(Class&amp;lt;T&amp;gt; type, T instance); public &amp;lt;T&amp;gt; getFavorite(Class&amp;lt;T&amp;gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.
1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.</description>
    </item>
    
    <item>
      <title>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item32/</link>
      <pubDate>Thu, 09 Jul 2020 16:12:48 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item32/</guid>
      <description>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.
가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.
실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item31/</link>
      <pubDate>Thu, 09 Jul 2020 13:42:19 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item31/</guid>
      <description>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.
아이템29의 Stack 클래스를 떠올려보면
1 2 3 4 5 6  public class Stack&amp;lt;T&amp;gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면
1 2 3 4 5  public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다.</description>
    </item>
    
    <item>
      <title>[아이템 30] 이왕이면 제네릭 메서드로 만들라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item30/</link>
      <pubDate>Thu, 09 Jul 2020 10:24:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item30/</guid>
      <description>[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.
1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 29] 이왕이면 제네릭 타입으로 만들라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item29/</link>
      <pubDate>Wed, 08 Jul 2020 16:53:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item29/</guid>
      <description>[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack&amp;lt;E&amp;gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } .</description>
    </item>
    
    <item>
      <title>[아이템 28] 배열보다는 리스트를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item28/</link>
      <pubDate>Wed, 08 Jul 2020 14:21:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item28/</guid>
      <description>[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.
반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입도 아니고 상위 타입도 아닙니다.
이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.
1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = &amp;#34;타입이 달라 넣을 수 없다.</description>
    </item>
    
    <item>
      <title>[아이템 27] 비검사 경고를 제거하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item27/</link>
      <pubDate>Wed, 08 Jul 2020 13:16:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item27/</guid>
      <description>[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.
제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.
대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.
1  Set&amp;lt;Fruits&amp;gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.</description>
    </item>
    
    <item>
      <title>[아이템 26] Raw 타입은 사용하지 마라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item26/</link>
      <pubDate>Tue, 07 Jul 2020 11:41:27 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-04/item26/</guid>
      <description>[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.
1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.
1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 25] 톱레벨 클래스는 한 파일에만 담으라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item25/</link>
      <pubDate>Sun, 05 Jul 2020 13:12:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item25/</guid>
      <description>[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.
Utensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.
1 2 3 4 5 6 7  class Utensil { static final String NAME = &amp;#34;pan&amp;#34;; } class Dessert { static final String NAME = &amp;#34;cake&amp;#34;; }   Main을 실행하면 &amp;ldquo;pancake&amp;quot;가 출력됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 24] 멤버 클래스는 되도록 static으로 만들어라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item24/</link>
      <pubDate>Sun, 05 Jul 2020 11:41:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item24/</guid>
      <description>[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.
중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.
 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.
정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다.</description>
    </item>
    
    <item>
      <title>[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item23/</link>
      <pubDate>Sat, 04 Jul 2020 15:46:26 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item23/</guid>
      <description>[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.
안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.</description>
    </item>
    
    <item>
      <title>[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item22/</link>
      <pubDate>Sat, 04 Jul 2020 13:21:14 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item22/</guid>
      <description>[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.
이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.
1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.</description>
    </item>
    
    <item>
      <title>[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item21/</link>
      <pubDate>Sat, 04 Jul 2020 11:14:32 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item21/</guid>
      <description>[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.
JAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.
즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.
자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.</description>
    </item>
    
    <item>
      <title>[아이템 20] 추상 클래스보다는 인터페이스를 우선하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item20/</link>
      <pubDate>Fri, 03 Jul 2020 14:21:15 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item20/</guid>
      <description>[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.
추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.
반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item19/</link>
      <pubDate>Fri, 03 Jul 2020 13:57:41 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item19/</guid>
      <description>[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.
상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 18] 상속보다는 컴포지션을 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item18/</link>
      <pubDate>Fri, 03 Jul 2020 11:42:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item18/</guid>
      <description>[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.
상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.
예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.</description>
    </item>
    
    <item>
      <title>[아이템 17] 변경 가능성을 최소화하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item17/</link>
      <pubDate>Thu, 02 Jul 2020 14:11:51 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item17/</guid>
      <description>[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점
클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item16/</link>
      <pubDate>Thu, 02 Jul 2020 13:38:11 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item16/</guid>
      <description>[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item15/</link>
      <pubDate>Thu, 02 Jul 2020 12:52:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-03/item15/</guid>
      <description>[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.
정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다.</description>
    </item>
    
    <item>
      <title>[아이템 14] Comparable를 구현할지 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item14/</link>
      <pubDate>Sat, 27 Jun 2020 17:11:39 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item14/</guid>
      <description>[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다.
Comparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.
그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.
1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다.</description>
    </item>
    
    <item>
      <title>[아이템 13] clone 재정의는 주의해서 진행하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item13/</link>
      <pubDate>Sat, 27 Jun 2020 15:04:12 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item13/</guid>
      <description>[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다. 하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다.
이 객체의 복사본을 생성해 반환합니다. &amp;lsquo;복사&amp;rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.
 x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다.</description>
    </item>
    
    <item>
      <title>[아이템 12] toString을 항상 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item12/</link>
      <pubDate>Sat, 27 Jun 2020 14:31:22 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item12/</guid>
      <description>[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다.
이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.
1 2  Student student = new Student(&amp;#34;kim&amp;#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.
toString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item11/</link>
      <pubDate>Sat, 27 Jun 2020 13:18:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item11/</guid>
      <description>[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.
 equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아집니다.</description>
    </item>
    
    <item>
      <title>[아이템 10] equals는 일반 규약을 지켜 재정의하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item10/</link>
      <pubDate>Sat, 27 Jun 2020 11:42:54 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-02/item10/</guid>
      <description>[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.
equals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다.
반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반</description>
    </item>
    
    <item>
      <title>[아이템 9] try-finally보다는 try-with-resources를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item9/</link>
      <pubDate>Sat, 20 Jun 2020 17:12:16 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item9/</guid>
      <description>[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 close를 해야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.
1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다.</description>
    </item>
    
    <item>
      <title>[아이템 8] finalizer와 cleaner 사용을 피하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item8/</link>
      <pubDate>Sat, 20 Jun 2020 15:12:33 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item8/</guid>
      <description>[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.
cleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.
단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.
finalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다.</description>
    </item>
    
    <item>
      <title>[아이템 7] 다 쓴 객체 참조를 해제하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item7/</link>
      <pubDate>Sat, 20 Jun 2020 12:15:43 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item7/</guid>
      <description>[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.</description>
    </item>
    
    <item>
      <title>[아이템 6] 불피요한 객체를 생성을 피하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item6/</link>
      <pubDate>Fri, 19 Jun 2020 18:33:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item6/</guid>
      <description>[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.
문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(&amp;#34;hello&amp;#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.
리터럴 방식 1  String str = &amp;#34;hello&amp;#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.</description>
    </item>
    
    <item>
      <title>[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item5/</link>
      <pubDate>Fri, 19 Jun 2020 17:15:21 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item5/</guid>
      <description>[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.
부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List&amp;lt;String&amp;gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = .</description>
    </item>
    
    <item>
      <title>[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item4/</link>
      <pubDate>Fri, 19 Jun 2020 15:51:43 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item4/</guid>
      <description>[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.
매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.
1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 3] private 생성자나 열거 타입으로  싱글턴임을 보증하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item3/</link>
      <pubDate>Thu, 18 Jun 2020 19:09:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item3/</guid>
      <description>[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.
싱글턴을 만드는 방식은 보통 둘 중 하나입니다.
public static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { .</description>
    </item>
    
    <item>
      <title>[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item2/</link>
      <pubDate>Thu, 18 Jun 2020 17:21:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item2/</guid>
      <description>[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.
첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 1] 생성자 대신 정적 팩토리 메서드를 고려하라</title>
      <link>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item1/</link>
      <pubDate>Thu, 18 Jun 2020 15:49:20 +0900</pubDate>
      
      <guid>https://qutrits.github.io/posts/effective-java-3e/chapter-01/item1/</guid>
      <description>[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드
1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.
반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.</description>
    </item>
    
    
    
    
    
    
    
    <item>
      <title>링크</title>
      <link>https://qutrits.github.io/links/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/links/</guid>
      <description>links</description>
    </item>
    
    <item>
      <title>모아보기 🗂️</title>
      <link>https://qutrits.github.io/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/collection/</guid>
      <description>공부하면서 정리한 것들 모아보기. 📒</description>
    </item>
    
    <item>
      <title>시리즈</title>
      <link>https://qutrits.github.io/series-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qutrits.github.io/series-list/</guid>
      <description>ser·ies</description>
    </item>
    
  </channel>
</rss>
