<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>&lt;Qubqub/&gt;</title>
    <link>https://qubqub.github.io/</link>
    <description>Recent content on &lt;Qubqub/&gt;</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 02 Aug 2021 10:11:42 +0900</lastBuildDate><atom:link href="https://qubqub.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[아이템 85] 자바 직렬화의 대안을 찾으라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item85/</link>
      <pubDate>Mon, 02 Aug 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item85/</guid>
      <description>[아이템 85] 자바 직렬화의 대안을 찾으라. 자바의 역직렬화에는 치명적인 단점이 있습니다. 신롸할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질 수 있습니다.
역직렬화 폭탄이란 서비스 거부 공격을 유발하는 스트림입니다.1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static byte[] bomb() { Set&amp;lt;Object&amp;gt; root = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;Object&amp;gt; s1 = root; Set&amp;lt;Object&amp;gt; s2 = new HashSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 100; i++) { Set&amp;lt;Object&amp;gt; t1 = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;Object&amp;gt; t2 = new HashSet&amp;lt;&amp;gt;(); t1.</description>
    </item>
    
    <item>
      <title>[아이템 78] 공유중인 가변 데이터는 동기화해 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item78/</link>
      <pubDate>Fri, 02 Jul 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item78/</guid>
      <description>[아이템 78] 공유중인 가변 데이터는 동기화해 사용하라. 동기화란 특정 메서드나 블럭에 한 쓰레드가 접근했을 때, 해당 객체에 락을 걸고 다른 쓰레드가 접근하지 못하도록 하는 것이다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -&amp;gt; { int i = 0; while (!</description>
    </item>
    
    <item>
      <title>[아이템 69] 예외는 진짜 예외 상황에서만 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item69/</link>
      <pubDate>Wed, 02 Jun 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item69/</guid>
      <description>[아이템 69] 예외는 진짜 예외 상황에서만 사용하라. 예외는 반드시 예외 상황에서만 사용해야한다. 일반적인 제어 흐름용으로 사용하면 안 됩니다.
1 2 3 4 5 6 7 8  try { int i = 0; while (true) { index[i++].doSomething(); } } catch (ArrayIndexOutOfBoundsException) { .. }   코드가 장황하고 직관적이지 않습니다. 성능도 일반적인 제어 흐름보다 느립니다.</description>
    </item>
    
    <item>
      <title>[아이템 57] 지역변수의 범위를 최소화하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item57/</link>
      <pubDate>Sun, 02 May 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item57/</guid>
      <description>[아이템 57] 지역변수의 범위를 최소화하라. 지역변수의 범위는 가능한 좁히는 게 좋습니다. 가장 좋은 방법은 선언과 동사에 초기화 해주는 것입니다. 초기화에 필요한 정보가 없다면 정보가 주어질 때까지 선언을 미루는 것입니다.. 물론 try-catch문은 이 규칙에서 예외입니다. try 블록 안에서 초기화해야하고 밖에서도 쓰일 경우 try 블록 앞에서 선언해야 합니다.

이러한 지역변수 초기화는 대표적으로 for (for-each), while로 비교할 수 있습니다.
1 2 3 4  // 컬렉션이나 베열을 순회하는 권장 관용구 for (Element e : c) { .</description>
    </item>
    
    <item>
      <title>[아이템 49] 매개변수가 유효한지 검사하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item49/</link>
      <pubDate>Fri, 02 Apr 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item49/</guid>
      <description>매개변수가 유효한지 검사하라. 메서드와 생성자는 대부분 특정 조건의 입력 매개변수에 특정 조건을 만족하기를 바랍니다. 만일 잘못된 값이 들어올 경우 보통 예외를 던지거나 컴파일 오류를 잡아내긴 하지만, 오류는 가능한 빨리 잡아내는 게 좋습니다. 그렇지 않으면 감지하기 어려워지고 감지하더라도 찾아내기 힘들어지는 경우도 있습니다.
이러한 경우를 방지하기 위해 매개변수를 미리 확인한다면 즉각적이고 깔끔한 방식으로 예외를 처리할 수 있습니다.

하지만 반드시 메서드를 실행하기 전에 매개변수 유효성 검사를 해야하는 것만은 아닙니다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때는 다시 고려를 해봐야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 42] 익명 클래스보다는 람다를 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item42/</link>
      <pubDate>Tue, 02 Mar 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item42/</guid>
      <description>[아이템 42] 익명 클래스보다는 람다를 사용하라. 자바 8부터는 함수형 프로그래밍을 지원합니다. 추상 메서드가 하나인(Single Abstract Method)인터페이스를 함수형 인터페이스라고 부르며 람다식을 사용해 만들 수 있습니다. 람다는 익명클래스에 비해 코드가 간결하고 가독성이 좋다는 장점이 있습니다.
1 2 3 4 5 6 7  // 익명 클래스 방식 Collections.sort(words, new Comparator&amp;lt;String&amp;gt;() { @Override public int compare(String s1, String s2) { return Interget.compare(s1.length(), s2.length()); } });   1 2 3  // 람다 활용 Collections.</description>
    </item>
    
    <item>
      <title>[아이템 34] int 상수 대신 열거 타입을 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item34/</link>
      <pubDate>Tue, 02 Feb 2021 10:11:42 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item34/</guid>
      <description>[아이템 34] int 상수 대신 열거 타입을 사용하라. 열거 타입이란 일정 개수의 상수 값을 정의하고 그 이외 값들은 허용하지 않는 타입입니다. 대표적으로 사계절, 요일, 태양계의 행성 등이 있습니다.
열거 타입을 지원하기 전 코드 1 2 3 4 5  // 정수 열거 패턴 - 상당히 취약하다. public static final int EAST = 0; public static final int WEST = 1; public static final int SOUTH = 2; public static final int NORTH = 3;   이 코드는 타입의 안전성을 보장할 수 없고 표현력도 좋지 않습니다.</description>
    </item>
    
    <item>
      <title>[아이템 33] 타입 안전 이종 컨테이너를 고려하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item33/</link>
      <pubDate>Thu, 09 Jul 2020 18:21:51 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item33/</guid>
      <description>[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.
1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public &amp;lt;T&amp;gt; void putFavorite(Class&amp;lt;T&amp;gt; type, T instance); public &amp;lt;T&amp;gt; getFavorite(Class&amp;lt;T&amp;gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.
1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.</description>
    </item>
    
    <item>
      <title>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item32/</link>
      <pubDate>Thu, 09 Jul 2020 16:12:48 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item32/</guid>
      <description>[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.
가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.
실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item31/</link>
      <pubDate>Thu, 09 Jul 2020 13:42:19 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item31/</guid>
      <description>[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.
아이템29의 Stack 클래스를 떠올려보면
1 2 3 4 5 6  public class Stack&amp;lt;T&amp;gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면
1 2 3 4 5  public void pushAll(Iterable&amp;lt;E&amp;gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다.</description>
    </item>
    
    <item>
      <title>[아이템 30] 이왕이면 제네릭 메서드로 만들라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item30/</link>
      <pubDate>Thu, 09 Jul 2020 10:24:41 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item30/</guid>
      <description>[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.
1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 29] 이왕이면 제네릭 타입으로 만들라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item29/</link>
      <pubDate>Wed, 08 Jul 2020 16:53:15 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item29/</guid>
      <description>[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack&amp;lt;E&amp;gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } .</description>
    </item>
    
    <item>
      <title>[아이템 28] 배열보다는 리스트를 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item28/</link>
      <pubDate>Wed, 08 Jul 2020 14:21:51 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item28/</guid>
      <description>[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.
반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입도 아니고 상위 타입도 아닙니다.
이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.
1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = &amp;#34;타입이 달라 넣을 수 없다.</description>
    </item>
    
    <item>
      <title>[아이템 27] 비검사 경고를 제거하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item27/</link>
      <pubDate>Wed, 08 Jul 2020 13:16:11 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item27/</guid>
      <description>[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.
제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.
대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.
1  Set&amp;lt;Fruits&amp;gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.</description>
    </item>
    
    <item>
      <title>[아이템 26] Raw 타입은 사용하지 마라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-04/item26/</link>
      <pubDate>Tue, 07 Jul 2020 11:41:27 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-04/item26/</guid>
      <description>[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.
1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.
1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 25] 톱레벨 클래스는 한 파일에만 담으라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item25/</link>
      <pubDate>Sun, 05 Jul 2020 13:12:41 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item25/</guid>
      <description>1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 코드는 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil, Dessert)를 참조합니다.
Utensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.
1 2 3 4 5 6 7  class Utensil { static final String NAME = &amp;#34;pan&amp;#34;; } class Dessert { static final String NAME = &amp;#34;cake&amp;#34;; }   Main을 실행하면 &amp;ldquo;pancake&amp;quot;가 출력됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 24] 멤버 클래스는 되도록 static으로 만들어라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item24/</link>
      <pubDate>Sun, 05 Jul 2020 11:41:14 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item24/</guid>
      <description>중첩 클래스nested class는 자신을 감싼 바깥 클래스에서만 쓰여야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.
중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.
 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스inner class에 해당합니다.
정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다. 정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰입니다.</description>
    </item>
    
    <item>
      <title>[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item23/</link>
      <pubDate>Sat, 04 Jul 2020 15:46:26 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item23/</guid>
      <description>때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.
안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.</description>
    </item>
    
    <item>
      <title>[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item22/</link>
      <pubDate>Sat, 04 Jul 2020 13:21:14 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item22/</guid>
      <description>인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.
이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.
1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.</description>
    </item>
    
    <item>
      <title>[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item21/</link>
      <pubDate>Sat, 04 Jul 2020 11:14:32 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item21/</guid>
      <description>JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.
JAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.
즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.
자바 라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.</description>
    </item>
    
    <item>
      <title>[아이템 20] 추상 클래스보다는 인터페이스를 우선하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item20/</link>
      <pubDate>Fri, 03 Jul 2020 14:21:15 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item20/</guid>
      <description>자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. JAVA 8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.
추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.
반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item19/</link>
      <pubDate>Fri, 03 Jul 2020 13:57:41 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item19/</guid>
      <description>여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.
상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.
  상속을 허용하는 클래스가 지켜야 할 제약 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 18] 상속보다는 컴포지션을 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item18/</link>
      <pubDate>Fri, 03 Jul 2020 11:42:22 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item18/</guid>
      <description>우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.
상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.
예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet&amp;lt;E&amp;gt; extends HashSet&amp;lt;E&amp;gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.</description>
    </item>
    
    <item>
      <title>[아이템 17] 변경 가능성을 최소화하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item17/</link>
      <pubDate>Thu, 02 Jul 2020 14:11:51 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item17/</guid>
      <description>불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.
📌 클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.
  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item16/</link>
      <pubDate>Thu, 02 Jul 2020 13:38:11 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item16/</guid>
      <description>1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.
다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.</description>
    </item>
    
    <item>
      <title>[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-03/item15/</link>
      <pubDate>Thu, 02 Jul 2020 12:52:21 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-03/item15/</guid>
      <description>잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 내부 데이터와 구현 정보를 외부로부터 얼마나 잘 숨겼느냐에 있습니다. 잘 설계된 컴포넌트는 모든 내부 구현을 숨기고, 구현과 API를 깔끔하게 분리합니다.
1. 정보 은닉(캡슐화)의 장점  개발 속도 증가: 여러 컴포넌트를 병렬로 개발할 수 있어 시스템 개발 속도가 빨라집니다. 관리 비용 절감: 각 컴포넌트를 더 빨리 파악할 수 있어 디버깅과 교체 비용이 낮아집니다. 성능 최적화: 특정 컴포넌트만 최적화할 수 있어 성능 향상에 도움이 됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 14] Comparable를 구현할지 고려하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-02/item14/</link>
      <pubDate>Sat, 27 Jun 2020 17:11:39 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-02/item14/</guid>
      <description>자바에서는 Comparable과 Comparator라는 두 가지 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬 기준을 구현하는 데 사용되고, Comparator는 다른 기준으로 정렬하고자 할 때 사용됩니다. 이번 포스트에서는 Comparable 인터페이스의 유일한 메서드인 compareTo에 대해 알아보겠습니다.
1. Comparable의 의미 Comparable을 구현했다는 것은 해당 클래스의 인스턴스들이 natural order를 갖는다는 것을 의미합니다. 이를 통해 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다:
1  Arrays.sort(a);   
2. compareTo 메서드의 규약 compareTo 메서드는 다음과 같은 규칙을 따릅니다:</description>
    </item>
    
    <item>
      <title>[아이템 13] clone 재정의는 주의해서 진행하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-02/item13/</link>
      <pubDate>Sat, 27 Jun 2020 15:04:12 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-02/item13/</guid>
      <description>1. clone과 Cloneable의 문제점 Cloneable 인터페이스를 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 이를 통해 객체의 복제가 제대로 이루어지리라 기대합니다. 하지만 clone 메서드의 일반 규약은 몇 가지 허점이 있어, 이를 주의 깊게 다루지 않으면 의도치 않은 결과를 초래할 수 있습니다.
다음은 Object 클래스의 clone 메서드에 대한 명세입니다.
 이 객체의 복사본을 생성해 반환합니다. 복사의 정확한 의미는 그 객체를 구현한 클래스에 따라 달라질 수 있지만, 일반적인 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 조건을 만족해야 합니다</description>
    </item>
    
    <item>
      <title>[아이템 12] toString을 항상 재정의하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-02/item12/</link>
      <pubDate>Sat, 27 Jun 2020 14:31:22 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-02/item12/</guid>
      <description>1. 기본 toString의 한계 기본적으로 자바 객체는 toString 메서드를 재정의하지 않으면 클래스 이름@해시코드(16진수) 형태로 문자열을 반환합니다. 이는 객체의 고유한 정보나 상태를 파악하는 데 적합하지 않습니다. 예를 들어, 다음과 같은 코드가 있다고 가정해봅시다.
1 2  Student student = new Student(&amp;#34;kim&amp;#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd 같은 형태로 출력됩니다. 이는 객체의 중요한 정보인 name과 age에 대한 내용을 알 수 없으므로, 객체의 상태를 파악하는 데 불편함을 줍니다.
2. toString을 재정의하는 좋은 방법 1) 객체의 주요 정보를 모두 포함하라 객체의 상태를 잘 표현할 수 있는 주요 필드나 속성을 toString 메서드에 포함해야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-02/item11/</link>
      <pubDate>Sat, 27 Jun 2020 13:18:21 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-02/item11/</guid>
      <description>1. 왜 hashCode도 재정의해야 할까? 자바의 HashMap, HashSet 같은 해시 기반 컬렉션은 객체의 고유한 해시값을 사용하여 저장, 검색, 비교를 수행합니다. 따라서 equals를 재정의하고도 hashCode를 재정의하지 않으면, 두 객체가 논리적으로는 같아도 해시값이 다를 수 있어 중복이 발생하거나 의도치 않게 검색에 실패할 수 있습니다.
equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.
Object 명세에서 정의한 hashCode 규약
  일관성: equals로 비교되는 정보가 변하지 않는 한, 애플리케이션 실행 동안 여러 번 hashCode를 호출해도 일관된 값을 반환해야 합니다.</description>
    </item>
    
    <item>
      <title>[아이템 10] equals는 일반 규약을 지켜 재정의하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-02/item10/</link>
      <pubDate>Sat, 27 Jun 2020 11:42:54 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-02/item10/</guid>
      <description>equals 메서드를 재정의하는 이유는 논리적 동치성을 비교하기 위함입니다. 논리적 동치성이란 객체의 참조값이 아닌 객체의 값이 같은지를 판단하는 것입니다. equals 메서드를 올바르게 재정의하지 않으면 객체 비교에서 예기치 않은 문제가 발생할 수 있습니다.
equals메서드를 오버라이딩 할 때는 다음의 규약을 따라야 합니다.
1. equals 규약 1) 반사성 (Reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.
  2) 대칭성 (Symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.</description>
    </item>
    
    <item>
      <title>[아이템 9] try-finally보다는 try-with-resources를 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item09/</link>
      <pubDate>Sat, 20 Jun 2020 17:12:16 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item09/</guid>
      <description>자바에는 InputStream, OutputStream, java.sql.Connection과 같은 직접 닫아줘야 하는 자원들이 존재합니다. 이 자원들을 제대로 닫지 않으면 메모리 누수와 같은 심각한 문제를 초래할 수 있습니다.
📌 실수를 유발할 수 있는 기존 코드 자바에서는 자원을 사용한 후 반드시 해제해야 하므로, 이전에는 try-finally를 사용하여 자원을 해제하는 방식이 흔했습니다. 하지만 이 방식은 복잡하고 오류를 유발할 가능성이 있습니다.
1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.</description>
    </item>
    
    <item>
      <title>[아이템 8] finalizer와 cleaner 사용을 피하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item08/</link>
      <pubDate>Sat, 20 Jun 2020 15:12:33 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item08/</guid>
      <description>1. finalizer와 cleaner란? 자바에서는 객체 소멸 시 특정 작업을 수행하는 두 가지 방법, finalizer와 cleaner를 제공합니다. finalizer는 Java 9부터 deprecated로 지정되었으며, cleaner는 그 대안으로 제공되지만 여전히 예측 불가능하고 성능 문제가 있습니다.
2. finalizer와 cleaner의 문제점 2.1 언제 실행될지 알 수 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 이들은 가비지 컬렉션이 수행될 때 동작하지만, 그 시점을 예측할 수 없기 때문에 시간에 민감한 작업을 이들에 의존할 수 없습니다.
2.2 finalizer의 느린 실행 finalizer는 lazy하게 실행됩니다.</description>
    </item>
    
    <item>
      <title>[아이템 7] 다 쓴 객체 참조를 해제하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item07/</link>
      <pubDate>Sat, 20 Jun 2020 12:15:43 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item07/</guid>
      <description>1. 메모리 누수가 발생하는 예시 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 메모리 누수 발생 가능  } private void ensureCapacity() { if (elements.</description>
    </item>
    
    <item>
      <title>[아이템 6] 불필요한 객체 생성을 피하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item06/</link>
      <pubDate>Fri, 19 Jun 2020 18:33:20 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item06/</guid>
      <description>객체를 생성할 때 기능이 동일한 객체를 매번 새로 생성하기보다는 객체를 재사용하는 것이 성능과 메모리 효율성 측면에서 더욱 적절합니다. 특히 **불변 객체(immutable objects)**는 항상 재사용이 가능하므로 이를 적극 활용해야 합니다.
📌 문자열 생성 방법 객체 생성 방식 - 피해야 되는 예시 1  String str = new String(&amp;#34;hello&amp;#34;);   이 방식은 매번 새로운 객체를 생성합니다. 같은 문자열을 사용하더라도 매번 새로운 인스턴스가 만들어져 낭비가 발생합니다.
리터럴 방식 1  String str = &amp;#34;hello&amp;#34;;   이 방식은 리터럴을 사용하여 JVM이 동일한 문자열을 캐싱하므로, 이미 같은 문자열이 있다면 이를 재사용합니다.</description>
    </item>
    
    <item>
      <title>[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item05/</link>
      <pubDate>Fri, 19 Jun 2020 17:15:21 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item05/</guid>
      <description>대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이를 처리하는 방식에 따라 코드의 유연성과 테스트 가능성이 크게 달라집니다. 이번 포스트에서는 이러한 의존성 처리의 잘못된 방식과 올바른 방식을 비교하고, 의존성 주입을 통한 해결 방법을 소개합니다.
부적절한 구현 📌 정적 유틸리티를 잘못 사용한 예 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() {} // 객체 생성 방지  public static boolean isValid(String word) { .</description>
    </item>
    
    <item>
      <title>[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item04/</link>
      <pubDate>Fri, 19 Jun 2020 15:51:43 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item04/</guid>
      <description>개요 java.lang.Math나 java.util.Arrays와 같은 유틸리티 클래스는 정적(static) 메서드와 정적 필드만을 포함하고 있어, 굳이 인스턴스를 생성할 필요가 없습니다. 그러나 기본 생성자를 명시적으로 막지 않으면, 클라이언트 코드가 실수로 인스턴스를 생성할 수 있습니다.
자바에서는 매개변수가 없는 생성자를 명시하지 않으면 기본 생성자가 자동으로 만들어지므로, 이를 방지하기 위해 private 생성자를 정의해야 합니다.
인스턴스화 방지 방법 1 2 3 4 5 6  public class UtilityClass { // 인스턴스화 방지용 private 생성자  private UtilityClass() { throw new AssertionError(); // 인스턴스 생성 시도 시 예외 발생  } }   이 코드의 동작 방식  private 생성자를 선언하여 외부에서 이 클래스를 인스턴스화하는 것을 막습니다.</description>
    </item>
    
    <item>
      <title>[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item03/</link>
      <pubDate>Thu, 18 Jun 2020 19:09:20 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item03/</guid>
      <description>싱글턴(Singleton) 패턴은 클래스의 인스턴스를 오직 하나만 생성하여 공유하는 방식입니다. 객체를 호출할 때마다 새로운 인스턴스를 만들지 않고, 동일한 인스턴스를 반환하는 방식이므로 메모리 낭비를 방지하고, 동작의 일관성을 유지할 수 있습니다.
싱글턴을 구현하는 주요 방식은 다음과 같습니다.
📌 public static final 필드를 이용한 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); // 유일한 인스턴스  private void Elvis() { .</description>
    </item>
    
    <item>
      <title>[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item02/</link>
      <pubDate>Thu, 18 Jun 2020 17:21:20 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item02/</guid>
      <description>매개변수가 많은 객체를 생성할 때, 생성자나 정적 팩토리 메서드 방식은 사용하기 불편해질 수 있습니다. 특히 매개변수의 순서나 타입이 비슷한 경우, 실수를 유발하거나 코드 가독성이 떨어지기 때문에 대안으로 빌더 패턴(builder pattern) 을 고려할 수 있습니다.
첫 번째 대안, 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   생성자를 통해 객체를 생성할 때 매개변수가 많으면, 어떤 값이 어떤 속성에 해당하는지 파악하기 어렵습니다. 특히 매개변수 타입이 같다면, 잘못된 순서로 입력해도 컴파일러가 오류를 잡지 못하고, 런타임에서 예상치 못한 동작을 초래할 수 있습니다.</description>
    </item>
    
    <item>
      <title>[아이템 1] 생성자 대신 정적 팩토리 메서드를 고려하라</title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-01/item01/</link>
      <pubDate>Thu, 18 Jun 2020 15:49:20 +0900</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-01/item01/</guid>
      <description>일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메서드를 이용할 수 있다. 객체 생성 시 public 생성자 대신 정적 팩토리 메서드(static factory method) 를 사용하는 것을 고려할 수 있습니다. 이를 통해 다양한 이점을 얻을 수 있는데, Java에서 자주 사용되는 패턴 중 하나입니다.
1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   Boolean 클래스에서 발췌한 예제 코드
장점 첫 번째, 이름을 가질 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item35/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item35/</guid>
      <description>[아이템 35] ordinal 메서드 대신 인스턴스 필드를 사용하라 대부분 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응됩니다. 모든 엵 ㅓ타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal 이라는 메서드를 제공합니다.
1 2 3 4 5 6 7 8 9 10  // ordinal을 잘못 사용한 예 public enum FRUITS { APPLE, BANANA, ORANGE; public int numberOfFruits() { return ordinal() + 1; } }   상수 선언 순서를 바꾸는 순간 numberOfFruits는 오작동하며 이미 사용중인 정수와 값이 같은 상수는 추가할 수 없고 중간에 값을 비울 수도 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item36/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item36/</guid>
      <description>[아이템 36] 비트 필드 대신 EnumSet을 사용하라. 열거한 값들이 집합으로 사용될 경우, 예전에는 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔습니다.
1 2 3 4 5 6 7 8 9 10  // 비트 필드 열거 상수 - 구닥다리 기법  public class Text { public static final int STYLE_BOLD = 1 &amp;lt;&amp;lt; 0; // 1  public static final int STYLE_ITALIC = 1 &amp;lt;&amp;lt; 1; // 2  public static final int STYLE_UNDERLINE = 1 &amp;lt;&amp;lt; 2; // 4  public static final int STYLE_STRIKETHROUGH = 1 &amp;lt;&amp;lt; 3; // 8  // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item37/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item37/</guid>
      <description>[아이템 37] ordinal 인덱싱 대신 EnumMap을 사용하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Plant { enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL } final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle; } @Override public String toString() { return name; } }   식물을 간단히 나타낸 코드입니다. 이들을 생애주기 별로 묶어봅시다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item38/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item38/</guid>
      <description>[아이템 38] 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라. 열거 타입은 확장할 수 없게 설계 되었습니다. 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 어폐가 있고 기반 타입과 확장된 타입들의 원소를 모두를 순회할 방법도 마땅치 않으며 확장성을 높이려면 고려할 요소가 늘어나 설계와 구현이 더 복잡해지기 때문입니다.

그러나 연산 코드는 확장할 수 있는 열거 타입과 어울립니다. API가 제공하는 기본 연산 외에 사용자가 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item39/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item39/</guid>
      <description>[아이템 39] 명명 패턴보다 애너테이션을 사용하라. 명명 패턴의 대표적인 예로 JUnit 3까지는 테스트 메서드 이름을 test로 시작하지 않으면 이 메서드를 그냥 지나쳤서 테스트를 통과했다고 오해하는 경우도 있었습니다.
JUnit 4부터는 이러한 문제점을 해결하기 위해 애너테이션을 전면 도입했습니다. 이번 예제에서는 자동으로 수행되는 간단한 테스트용 애너테이션으로, 예외가 발생하면 해당 테스트를 실패로 처리합니다.
1 2 3 4 5 6 7 8  /** * 테스트 메서드임을 선언하는 애너테이션 * 매개변수 없는 정적 메서드 전용 */ @Retention(RetentionPolicy.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item40/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item40/</guid>
      <description>[아이템 40] @Override 애너테이션을 일관되게 사용하여라. @Override애너테이션은 상위 타입 메서드를 재정의 했다는 뜻으로 메서드 선언에 달 수 있습니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 버그를 찾아보자  public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-05/item41/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-05/item41/</guid>
      <description>[아이템 41] 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라. 마커 인터페이스란 메서드 선언을 포함하지 않고, 단지 구현하는 클래스의 특정 속성을 표시해주는 것입니다. 대표적으로 Serializable인터페이스가 있습니다.
마커 애너테이션이 등장하면서 마커 인터페이스가 구식이 되었다는 얘기가 있는데, 이는 사실이 아닙니다. 마커 인터페이스는 마커 애너테이션 보다 좋은 점도 있습니다.
첫 째로 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입을 쓸 수 있지만, 마커 애너테이션은 그렇지 않습니다. 마커 인터페이스는 타입이고 마커 애너테이션을 사용하면 런타임에야 발견할 수 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item43/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item43/</guid>
      <description>[아이템 43] 람다보다는 메서드 참조를 사용하라. 메서드 참조를 이용하면 람다보다 간단하게 코드를 작성할 수 있습니다.
 문법 
클래스이름::메소드이름
또는
참조변수이름::메소드이름
 다음의 예제 코드는 키가 맵에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값에 1을 증가시킵니다.
1  map.merger(key, 1, (count, incr) -&amp;gt; count + incr);   위 코드는 Integer의 sum메서드를 이용해서 대체할 수 있으며 메서드 참조를 이용해 간결하게 표현할 수 있습니다.
1  map.merger(key, 1, Integer::sum);   메서드 참조를 이용하면 코드가 간결해지며 가독성이 좋아지는 경우가 있지만 때로는 람다에서는 매개변수의 이름으로 가이드를 할 수도 있고 메서드 참조보다 더 읽기 쉽고 가독성이 더 좋아지는 경우가 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item44/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item44/</guid>
      <description>[아이템 44] 표준 함수형 인터페이스를 사용하라. java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 정의되어 있으므로 용도에 맞는 게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용합시다. 일관성을 높일 수 있고 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 증가할 것입니다. java.util.function에는 총 43개의 인터페이스가 있지만 기본 인터페이스 6개만 기억하면 나머지는 충분히 유추할 수 있으며 나머지는 필요할 때마다 찾아서 사용하면 됩니다.

표준 함수형 인터페이스 대부분은 기본 타입만 지원합니다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하지 맙시다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item45/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item45/</guid>
      <description>[아이템 45] 스트림은 주의해서 사용하라. 스트림이 제공하는 핵심 개념 중 핵심은 두 가지로 나눌 수 있습니다.
 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻합니다. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념입니다.  스트림은 소스 스트림으로 시작해서 종단(최종) 연산(terminal operation)으로 끝나며, 그 사이에 하나 이상의 중간 연산자가 있을 수 있습니다. 중간 연산자는 어떠한 방식으로 변환(transform) 합니다. 최종 연산은 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item46/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item46/</guid>
      <description>[아이템 46] 스트림에서는 부작용이 없는 함수를 사용하라. 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분입니다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 하는데, 순수 함수란 입력만이 결과에 영향을 주는 함수를 말합니다. 즉 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않습니다.
다음은 텍스트 파일에서 단어별 수를 세어 빈도표를 만드는 코드입니다.
1 2 3 4 5 6 7  // 스트림을 이해하지 못한 코드 - 따라 하지 말 것 Map&amp;lt;String, Long&amp;gt; freq = new HashMap&amp;lt;&amp;gt;(); try (Stream&amp;lt;String&amp;gt; words = new Scanner(file).</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item47/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item47/</guid>
      <description>[아이템 47] 반환 타입으로는 스트림보다 컬렉션이 낫다. 사실 Stream 인터페이스 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 Iterable 인터페이스가 정의한 방식대로 동작합니다. 하지만 for-each로 스트림을 반복할 수 없는 이유는 Stream이 Iterable을 확장하지 않아서입니다.

Collection인터페이스는 Iterable의 하위 타입이고 stream의 메서드도 제공하니 반복과 스트림을 동시에 지원합니다. 따라서 원소 시퀀수를 공개하는 공개 API의 반환타입에는 Collection이나 그 하위 타입을 사용하는게 일반적으로 좋습니다.
정리  원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하길 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 고려하라 컬렉션을 반환할 수 있다면 그렇게 하고 반환 전부터 이미 원소들을 컬렉션에 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList같은 표준 컬렉션에 담아 반환하라.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-06/item48/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-06/item48/</guid>
      <description>[아이템 48] 스트림 병렬화는 주의해서 적용하라. 자바 8에 추가된 parallel 메서드는 파이프라인을 병렬 실행할 수 있습니다. 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 주의를 기울여야합니다. 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없습니다. 
대체로 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋습니다. 이 자료구조들은 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특성이 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item50/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item50/</guid>
      <description>[Item50] 적시에 방어적 복사본을 만들라 이번 아이템에서는 지난 Item17에 다루었던 불변에 대한 주제가 포함되어있습니다. 어떤 객체든 객체의 허락 없이는 외부에서 함부로 내부를 수정하게 하는 일이 없아야 합니다. 하지만 주의를 기울이지 않으면 자신도 모르게 내부를 수정하도록 코드를 짜는 경우가 생길 수 있습니다.

다음은 부주의로 일어날 수 있는 상황을 예시로 든 코드입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public final class Period { private final Date date; private final Date end; public Period(Date start, Date end) { if (start.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item51/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item51/</guid>
      <description>[아이템 51] 메서드 시그니처를 신중히 설계하라. 메서드 이름을 신중히 짓자. 항상 표준 명명 규칙을 따라야합니다. 이름만 보고 이해할 수 있고, 일관성있게 짓는 것이 핵심입니다. 그 다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것입니다. 되도록이면 긴 이름은 피하는 것이 좋습니다. 물론 조직내에 규율이 있다면 그 규율을 지키는 게 우선입니다.
편의 메서드를 너무 만들지 말자. 메서드가 너무 많은 클래스는 파악하고 유지보수 하기도 힘들고 객체지향 SOLID원칙 중 Single Responsiblity Principle에 위반될 수도 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item52/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item52/</guid>
      <description>[아이템 52] 다중정의는 신중히 사용하라. 다음은 컬렉션을 집합, 리스트, 그 외로 구분하고자 만든 프로그램입니다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class CollectionClassifier { public static String classify(Set&amp;lt;?&amp;gt; s) { return &amp;#34;Set&amp;#34;; } public static String classify(List&amp;lt;?&amp;gt; lst) { return &amp;#34;List&amp;#34;; } public static String classify(Collection&amp;lt;?&amp;gt; c) { return &amp;#34;Unknown Collection&amp;#34;; } public static void main(String[] args) { Collection&amp;lt;?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item53/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item53/</guid>
      <description>[아이템 53] 가변인수는 신중히 사용하라. 가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있습니다. 다음 예제는 int 인자의 합을 구하는 가변인수 메서드입니다.
1 2 3 4 5 6 7  static int sum(int... args) { int sum = 0; for (int args: args) { sum += args; } return sum; }   1개 이상의 인수가 필요한 경우도 있습니다. 다음 예제는 1개 이상의 인수를 필요료하는 가변인수 메서드의 잘못된 구현입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item54/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item54/</guid>
      <description>[아이템 54] null이 아닌, 빈 컬렉션이나 배열을 반환하라. 1 2 3 4 5 6  // 컬렉션이 비어있으면 null을 반환 - 따라하지 말 것 private final List&amp;lt;Cheese&amp;gt; cheesesInStock = ...; public List&amp;lt;Cheese&amp;gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList&amp;lt;&amp;gt;(cheesesInStock); }   null을 반환할 경우 클라이어트는 이 null 상황을 처리하는 코드를 추가로 작성해야합니다.
1 2 3 4  List&amp;lt;Cheese&amp;gt; cheesesInStock = shop.getCheeses(); if (cheese != null &amp;amp;&amp;amp; cheeses.contains(cheese.STILTON)) { system.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item55/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item55/</guid>
      <description>[아이템 55] 옵셔널 반환은 신중히 하라 자바 8이전에는 메서드가 특정 값을 반환할 수 없을때 취할 수 있는 선택지가 두 가지가 있었습니다. 예외를 던지거나, null을 반환하는 것입니다. 두 방법 모두 허점이 있습니다. 예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 바용도 만만치 않습니다. null을 반환할 수 있는 메서드를 호출하면 null 처리를 별도로 해줘야합니다. null 처리를 무시하면 나중에 NPE가 발생할 수 있습니다.

자바 8부터는 Optional을 지원했습니다. Optional&amp;lt;T&amp;gt;는 null이 아닌 T타입 참조를 하나 담거나, 아무것도 담지 않을 수 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-07/item56/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-07/item56/</guid>
      <description>[아이템 56] 공개된 API 요소에는 항상 문서화 주석을 작성하라. javadocd이라는 유틸리티를 이용하면 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해줍니다.
메서드용 문서화 주석에는 해당 메서드와 클라이어트 사이의 규약을 명료하게 기술해야 합니다. 핵심 포인트는 how가 아닌 what입니다. 무엇을 하는지에 대한 설명이 있어야 합니다. 또한 메서드를 호출하기위한 조건, 수행된 후에 만족해야 하는 사후조건, 부작용도 모두 나열되어야 합니다. 잘 쓰인 문서인지 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길뿐입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item58/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item58/</guid>
      <description>[아이템 58] 전통적인 for 문보다는 for-each를 사용하라. for 문은 코드가 장황해질 수 있고, 요소 종류가 늘어날 수록 오류가 생길 가능성이 있습니다. for-each (정식명칭 향상된 for문)은 이러한 단점들을 해결해줄 수 있습니다.
1 2 3  for (Element e : elements) { .... // e로 무언가를 한다. }   컬렉션을 중첩해서 사용하면 for-each 문의 이점은 더욱 커집니다.
1 2 3 4 5 6 7 8 9 10 11 12 13  // 버그를 찾아보자 enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item59/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item59/</guid>
      <description>[아이템 59] 라이브러리를 익히고 사용하라. 0부터 명시한 수 까지 무작위 정수를 하나 생성하려고 합니다. 다음은 흔히 마주할 수 있는 문제있는 메서드입니다.
1 2 3 4 5  static Random ran = new Randon(); static int random(int n) { return Math.abs(ran.nextInt()) % n; }   이 코드에는 세 가지 문제점이 있습니다. 첫 번째. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복됩니다. 두 번째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 반복됩니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item60/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item60/</guid>
      <description>[아이템 60] 정확한 답이 필요하다면 float와 double은 피하라. float와 dobule은 과학과 공학 계산용으로 설계 되었습니다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 &amp;lsquo;근사치&amp;rsquo;로 계산하도록 설계되었습니다. 따라서 정확한 계산 결과가 필요할 때는 사용하면 안 됩니다. 특 히 금용 관련 계산과 맞지 않습니다. 0.1 혹은 10의 음의 거듭 제곱수(10^-1, 10-^2)를 표현할 수 없기 때문입니다.
예를 들어 1.03달러에서 42센트를 사용하고 남은 돈을 계산한다고 가정해봅시다.
1  System.out.println(1.03 - 0.42);   이 코드는 0.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item61/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item61/</guid>
      <description>[아이템 61] 박싱된 기본 타입보다는 기본 타입을 사용하라. 자바의 데이터 타입은 기본형과 참조형이 있습니다. 기본형에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 합니다. 기본 타입과 박싱된 기본 타입은 분명한 차이가 있으며 용도에 맞게 사용해야합니다.
박싱된 기본 타입은 값 뿐만 아니라 식별성이 더해졌습니다. 즉 값이 같아도 서로 다르게 식별될 수 있습니다. 그리고 박싱 타입은 null을 가질 수 있습니다. 추가로 기본 타입은 박싱 타입보다 메모리와 시간 측면에서 더 효율적입니다.
1 2 3  // 잘못 구현된 비교자 Comparator&amp;lt;Integer&amp;gt; naturalOrder = (i, j) -&amp;gt; (i &amp;lt; j) ?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item62/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item62/</guid>
      <description>[아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라. 문자열은 다른 값 타입을 대신하기엔 적절하지 않습니다.
1 2  // 흔한 타입을 문자열로 처리한 부적절한 예 String compoundKey = className + &amp;#34;#&amp;#34; + i.next();   두 요소를 구분해주는 #이 두 요소 중 하나에서 쓰였다면 혼란을 초래할 수 있습니다. 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커집니다. 이럴 경우 전용 클래스를 새로 만드는 편이 낫습니다. 보통 private 정적 멤버 클래스로 선언합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item63/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item63/</guid>
      <description># [아이템 63] 문자열 연결은 느리니 주의하라. 문자열 연결 연산자로 문자열을 n개를 잇는 시간은 n^2에 비례합니다. 문자열은 immutable이라 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없습니다.
1 2 3 4 5 6 7  public String statement() { String result = &amp;#34;&amp;#34;; for (int i = 0; i &amp;lt; numItems(); i++) { result += lineForItem(); // 문자열연결  } return result; }   StringBuilder를 활용하면 성능을 크게 개선할 수 있습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item64/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item64/</guid>
      <description>[아이템 64] 객체는 인터페이스를 사용해 참조하라. 1 2  // 좋은 예 Set&amp;lt;Student&amp;gt; student = new HashSet&amp;lt;&amp;gt;();   1 2  // 나쁜 예. 클래스 참조 HashSet&amp;lt;Student&amp;gt; student = new HashSet&amp;lt;&amp;gt;();   인터페이스를 활용하면 유연함을 얻을 수 있습니다. 구현체를 교체하고 싶으면 구현 클래스만 바꾸면 됩니다.
1 2  // HashSet -&amp;gt; LinkedHashSet 교체 Set&amp;lt;Student&amp;gt; student = new LinkedHashSet&amp;lt;&amp;gt;();   하지만 구현체를 바꿀 경우 주의할 점이 있습니다. 기존 구현체만의 특별한 기능을 제공하는 게 있다면, 바꿀 구현체에도 있는지 혹은 사이드 이펙트도 충분히 고려해야 합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item65/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item65/</guid>
      <description>[아이템 65] 리플렉션보다는 인터페이스를 사용하라. 리플렉션 기능을 활용하면 클래스에 접근 할 수 있습니다. Class객체가 주어지면 생성자, 메서드, 필드에 해당하는 Consturct, Method, Field 인스턴스를 가져올 수 있고 그 인스턴스들로는 그 클래스의 시그니처 등을 가져올 수 있습니다.

Method.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해줍니다 물론 장점만있는 건 아닙니다. 단점은 다음과 같습니다.
 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 예외 검사도 마찬가지입니다. 리플렉션 기능으로 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려고하면 런타임 오류가 발생합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item66/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item66/</guid>
      <description>[아이템 66] 네이티브 메서드는 신중히 사용하라. 자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다. 네이티브 메서드란 C나 C++같읕 네이비티브 프로그래밍 언어로 작성한 메서드를 말합니다. 네이티브 메서드의 주요 쓰임은 세 가지가 있습니다.
 레지스트리 같은 플랫폼 특화 기능을 사용한다. 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  자바 9부터는 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었고 자바에서 네이티브 메서드를 사용할 필요가 점점 줄어드는 추세입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item67/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item67/</guid>
      <description>[아이템 67] 최적화는 신중히 하라. 최적화는 좋은 결과보다 해로운 결과로 이어지기 쉽고, 자칫하면 빠르지도 않고 제대로 동작하지 않는 소프트웨어를 탄생시키는 것과 같습니다. 그러므로 최적화 할때는 득과실을 잘 생각해봐야 합니다.
성능을 제한하는 설계를 피하라 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리 혹은 외부 시스템과의 소통 방식입니다. 대표적으로 API, 네트워크 프로토콜 등이 있습ㄴ디ㅏ. 이런 설계 요소들은 완성 후에는 변경하기 어려우며 동시에 시스템 성능을 심각하게 제한할 수 있습니다.
API 설계할 때 성능에 주는 영향을 고려하라.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-08/item68/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-08/item68/</guid>
      <description>[아이템 68] 일반적으로 통용되는 명명 규칙을 따르라. 자바이 명명 규칙은 크게 철자와 문법, 두 범주로 나뉘고 명명 규칙을 지켜야 좋은 프로그래밍이 될 수 있습니다. 대표적으로 메서드와 필드 내임의 첫 글자는 소문자를 사용합니다. 하지만 상수 필드의 경우 예외입니다. 상수는 모두 대무자를 이용하며 단어 사이는 _로 구분 합니다. ex)MAX_VALUE.. 상수 필드는 값이 static final 필드를 말합니다. 타입 매개변수 같은 경우 한 문자로 표현되며, 임의의 타입에는 T를, 컬렉션 원소의 타입은 E, 맵의 키와 값에는 K, V를, 예외는 X, 메서드의 반환 타입에는 R을 사용합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item70/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item70/</guid>
      <description>[아이템 70] 복구할 수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 시용하라. 자바에서는 기본적으로 오류는 checked exception, runtime exception, error 이렇게 세 가지로 나눌 수 있습니다. 100% 확실한 건 아니지만 일반적으로 사용하는 상황은 다음과 같습니다.


호출 하는 쪽에서 복구하리라 여거지는 상황에서는 검사 예외를 사용합시다. 이것이 검사 예외랑 비검사 예외를 구분하는 가장 기본적인 규칙입니다. catch로 잡아서 처리하거나 thorws로 예외를 호출한쪽으로 전파하고 호출했을 때 발생할 수 있는 있다는 걸 API 사용자에게 알리는 것입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item71/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item71/</guid>
      <description>[아이템 71] 필요 없는 검사 예외 사용은 피하라. 검사 예외를 필요한 곳에만 사용하면 프로그램의 안전성을 높여주지만, 과하게 사용하면 오히려 쓰기 불편한 API가 됩니다. API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 잇는 조치를 취할 수 있는 경우 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item72/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item72/</guid>
      <description>[아이템 72] 표준 예외를 사용하라. 자바에서는 기본적으로 다양한 예외를 제공해줍니다. 예외를 만들기 전 먼저 기존 라이브러리를 확인해보는 것이 좋습니다. 기존에 있는 라이브러리를 사용하면 API가 다른 사람이 익히기 쉬워집니다. 또한 예외 클래스가 적어질 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸리기 때문입니다.


Exception, RuntimeException, Throwable, Error는 직적 재사용하지 않는 게 좋습니다. 다른 예외들의 상위 클래스이므로 즉 여러 예외를 포괄하기 때문에 안정적으로 테스트할 수 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item73/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item73/</guid>
      <description>[아이템 73] 추상화 수준에 맞는 예외를 던져라. 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 경우 예상치 못한 예외를 접하고 당황할 수가 있습니다. 이 문제를 피하려면 상위 계층에서 저수주 예외를 잡아 자신의 추상화 수준에 맞는 예외를 던져야 합니다. 이를 예외 번역이라 부릅니다.
1 2 3 4 5 6  try { ... } catch (LowLevelException e) { // 추상화 수준에 맞게 번역.  throw new HighLevelException(..); }   AbstractSequentialList에서 수행하는 예외번역의 예시</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item74/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item74/</guid>
      <description>[아이템 74] 메서드가 던지는 모든 예외를 문서화하라. 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화를 합시다. 상위 클래스 하나로 선언하는 일은 삼가는 게 좋습니다. 어떤 예외를 호출하는지 명확하게 알 수 없고, 같은 맥락에서 다른 예외가 발생할 여지가 있을 경우 이러한 것까지 다 삼켜버릴 수 있기 때문입니다. 비검사 예외 같은 경우 메서드 선언에 throws를 넣는 건 권장하지 않습니다. 검사냐 비검사냐에 따라 API 사용자가 할 일이 달라지므로 이 둘은 확실히 구분해두는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item75/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item75/</guid>
      <description>[아이템 75] 예외 상세 메시지에 실패 관련 정보를 담으라. 스택 트레이스는 예외 객체의 toString 메서드를 호출해 얻는 문자열입니다. toString 메서드에 발생 원인에 대한 정보는 가능한 많을 수록 좋습니다. 물론 장황하지 않고 필요한 정보만 담는 것입니다. 가장 좋은 건 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담는 것입니다. 물론 보안관 관련된 정보는 유의해서 다루어야 합니다.


ex) IndexOutOfBoundsException의 상세 메세지에는 범위의 최솟값, 최댓값, 범위를 벗어난 인덱스의 값을 담는 것입니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item76/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item76/</guid>
      <description>[아이템 76] 가능한 한 실패 원자적으로 만들라. 여기서 말하는 실패 원자적이란 호출한 메서드가 실패하더라도 해당 객체는 호출 전 상태로 유지되는 것입니다. 가장 간단한 방법은 불변 객채로 설계하는 것입니다. 가변 객체일 경우 작업 수행 전에 유효성을 검사합는 것입니다.
1 2 3 4 5 6 7 8  public Object pop() { if (size == 0) { throw new EmptyStachException(); } Object result = el[--size]; el[size] = null; // 참조 해제  return result; }   유효성 검사하는 부분이 없어도 ArrayOutOfBoundsException을 던지지만 이는 추상화 수준에 상황에 어울리지 않습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-09/item77/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-09/item77/</guid>
      <description>[아이템 77] 예외를 무시하지 마라. 발생할 수 있는 실수
1 2 3 4 5  try { ... } catch (IllegalArgumentException e){ }   초보 프로그래머가 할 수 있는 실수입니다. catch 블록에서 아무것도 하지 않으면 catch가 존재할 이유가 없어지는 것과 마찬가지입니다. 예외가 발생허더라도 계속 지나칠 수 있습니다. 이는 심각한 결함으로 이어질 수 있습니다. 만약 예외를 무시하기로 결정한 부분이라면 IllegalArgumentException ignored로 바꿔놓는 것이 좋습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item79/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item79/</guid>
      <description>[Itemm 79] 과도한 동기화는 피하라. 과도한 동기화는 성능을 저하시키고 교차상태에 빠뜨릴 수 있다.

liveness, safety failures를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에게 양보하면 안 된다. ex) 동기화된 영역 안에서 재정의할 수 있는 메서드 호출 x, 클라이언트가 념겨준 함수 객체 호출 x
  과도한 동기화는 성능을을 저하 시킨다. 가변 클래스를 작성하거든 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화 하게 하던가, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item80/</guid>
      <description>[아이템 80] 스레드보다는 실행자, 태스크, 스트림을 애용하라. Excutor Framework는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.
1 2 3  ExecutorService exec = Executors.newSingleThreadExecutor(); exec.excute(runnable); // 이 실행자에게 task를 넘김 exec.shutdown(); // graceful하게 종료 (이 작업이 실패하면 VM 자체가 종료되지 않을 것)   이 외에도 다양한 기능을 실행할 수 있다. 실행자 서비스를 사용하기에 까다로운 애플리케이션도 있는데, 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item81/</guid>
      <description>[아이템 81] wait와 notify보다는 동시성 유틸리티를 애용하라. wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하라.

java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.
 실헹자 프레임워크 동시성 컬렉션 동기화 장치  동시성 컬렉션은 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 구현한다. 따라서 컬렉션에서 동기성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 속도가 느려진다.

동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 건 불가능하다. 그레서 여러 기본 동작을 하나의 원자적 동작으로 묶는 &amp;lsquo;상태 의존적 수정&amp;rsquo; 메서드들이 추가되었다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item82/</guid>
      <description>[아이템 82] 스레드 안전성 수준을 문서화하라. 일반적으로 스레드 안정성이 높은 순
 불변: 외부 동기화가 필요없다. 대표적으로 String, Long, BigInteger 무조건적 스레드 안전: 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 사용해도 안전 대표적으로 ConcurrentHashMap 조건부 스레드 안전: 일부 메서드는 동시에 사용하려면 외부 동기화가 필요. Collections.synchronized 래퍼 메서드가 반환한 컬렉션이 여기 속함 스레드 비안전: 동시에 시용하려면 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야한다. ArrayList, HashMap 같은 기본 컬렉션.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item83/</guid>
      <description>[아이템 83] 지연 초기화는 신중히 사용하라. 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요햔 시점까지 늦추는 것이다. 지연 초기화는 인스턴스 생성시 초기화 비용을 줄일 수 있지만, 지연 초기화하는 필드에 접근하는 비용은 커진다. 지연 초기화를 잘못사용하면 실제로 성능이 더 느려질 수도 있다.


멀티 스레드 환경에서 지연 초기화를 하기에는 까다롭다. 지연 초기화하는 필드를 둘 이상 스레드가 공유한다면 동기화해야 한다. 일반적으로 일반적인 초기화가 지연 초기화보다 낫다.
1 2  // 인스턴스 필드를 초기화하는 일반적인 방법 private final FieldType field = computerFieldValue();   1 2 3 4 5 6 7 8 9  // 지연 초기화 - sychronized 방식 private FieldType field; private sychronized FieldType getField() { if (field == null) { field = computerFieldValue(); } return field; }   1 2 3 4 5 6 7 8  // 정적 필드용 지연 초기화 홀더 클래스 관용구 private static class FieldHolder { static final FieldType field = computerFieldValue(); } private static FieldType getField() { return FieldHolder.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-10/item84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-10/item84/</guid>
      <description>[아이템 84] 프로그램의 동작을 스레드 스케줄러에 기대지 말라. 구체적인 스케줄링 정책은 운영체제 마다 다를 수 있다. 따라서 이 정책에 죄지우지 되면 안 된다. 실행 가능한 스레드의 평균적인 수를 프로세스 수보다 지나치게 많아지지 않도록 하는 것이 좋은 프로그래램이다. 그래야 스케줄러가 고민할 거리가 줄기 때문이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item86/</guid>
      <description>[아이템 86] Serializable을 구현할지는 신중히 결정하라. Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵습니다. 직렬화 당시 내부 구현 방식에 묶이고, 캡슐화가 깨지는 위험이 있습니다. 직렬화된 클래스는 고유 식별 번호를 부여받는데, serialVersionUID를 명시하지 않으면 런타임에 SHA-1을 적용하여 자동으로 클래스 안에 생성해 넣는데, 클래스의 이름, 멤버 등이 포함됩니다. 그래서 나중에 이들 중 하나를 수정한다면 UID 값도 변하여 호환성이 깨져버립니다.
그 다음 문제는 역직렬화는 숨은 생성자 입니다. 기본 역직렬화를 사용하면 불변식이 깨지고 허가되지 은 접근에 쉽게 노출됩니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item87/</guid>
      <description>[아이템 87] 커스텀 직렬화 형태를 고려해보라. 이상적인 직렬화는 물리적인 모습과 독립된 논리적인 모습을 표현해야한다. 하지만 기본 직렬화 형태는 객체가 포함한 모든 데이터와 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아낸다.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class Name implements Serializable { /* * 성. null이 아니어야 함. * @serial */ private final String lastName; /* * 이름.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item88/</guid>
      <description>[아이템 88] readObject 메서드는 방어적으로 작성하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 방어적 복사를 사용하는 불변 클ㄹ스  public final class Period { private final Date start; private final Date end; /** * @param start 시작 시간 * @param end 종료 시각. 시작 시간보다 뒤어야 한다 * @throws IllegalArgumentException 시작 시간이 종료 시간보다 늦을 때 발생한다 * @throws NullPointerException start나 end가 null일시 발생 */ public Period(Date start, Date end) { this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item89/</guid>
      <description>[아이템 89] 인스턴스 수를 통제해야 한다면 readResolve 보단는 열거타입을 사용하라. 1 2 3 4 5 6 7  // 싱글턴 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } }   Serializable을 구현하는 순간 더이상 싱글턴이 아니다. 어떤 readObject를 사용하든 초기화될때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다.


readResolve 기능을 활용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다</description>
    </item>
    
    <item>
      <title></title>
      <link>https://qubqub.github.io/effective-java-3e/chapter-11/item90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/effective-java-3e/chapter-11/item90/</guid>
      <description>[아이템 90] 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라. 직렬화 프록시 패턴을 이용하면 앞서 애기했던 단점들을 줄일 수 있다.먼저 바깥 클래스의 논리적인 상태를 표현하는 중첩 클래스를 private static으로 생성한다. 이 중첩 클래스가 바깥 클래스의 직렬화 프록시다. 이 클래스는 단순히 인스로 넘어온 인스턴스의 데이터만 복사하고 바깥 클래스와 모두 Serializable을 구현해야한다.
1 2 3 4 5 6 7 8 9 10 11  // Period 클래스용 직렬화 프록시 private static class SerializationProxy implements Serializable { private final Date start; private final Date end; SerializationProxy(Period p) { this.</description>
    </item>
    
    
    <item>
      <title>링크</title>
      <link>https://qubqub.github.io/links/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/links/</guid>
      <description>links</description>
    </item>
    
    <item>
      <title>모아보기 🗂️</title>
      <link>https://qubqub.github.io/collection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/collection/</guid>
      <description>collection</description>
    </item>
    
    <item>
      <title>시리즈</title>
      <link>https://qubqub.github.io/series-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qubqub.github.io/series-list/</guid>
      <description>ser·ies</description>
    </item>
    
    
  </channel>
</rss>
